# Tokens generados desde: docs/Analizador-Lexico/examples/limit-04.txt
# Formato: tipo_token lexema linea columna [indice_palabra_clave]
# Tipos: IDENTIFIER=0, NUMBER=1, STRING=2, OPERATOR=3, DELIMITER=4, KEYWORD=5, UNKNOWN=6, EOF=7
# Palabras clave: fn=0, let=1, mut=2, if=3, else=4, match=5, while=6, loop=7, for=8, in=9, break=10, continue=11, return=12, true=13, false=14

5 fn 4 1 0
0 main 4 4
4 ( 4 8
4 ) 4 9
4 { 4 11
5 let 6 5 1
5 mut 6 9 2
0 contador 6 13
6 : 6 21
0 i32 6 23
3 = 6 27
1 0 6 29
4 ; 6 30
5 let 7 5 1
0 limite 7 9
6 : 7 15
0 i32 7 17
3 = 7 21
1 100 7 23
4 ; 7 26
5 let 8 5 1
0 pi 8 9
6 : 8 11
0 f64 8 13
3 = 8 17
1 3.14159 8 19
4 ; 8 26
5 let 9 5 1
0 nombre 9 9
6 : 9 15
0 str 9 17
3 = 9 21
2 "Analizador LÃ©xico" 9 23
4 ; 9 43
5 let 10 5 1
0 activo 10 9
6 : 10 15
0 bool 10 17
3 = 10 22
5 true 10 24 13
4 ; 10 28
5 while 13 5 6
0 contador 13 11
3 < 13 20
0 limite 13 22
4 { 13 29
5 if 14 9 3
0 contador 14 12
3 % 14 21
1 2 14 23
3 == 14 25
1 0 14 28
4 { 14 30
0 contador 15 13
3 = 15 22
0 contador 15 24
3 + 15 33
1 1 15 35
4 ; 15 36
4 } 16 9
5 else 16 11 4
4 { 16 16
0 contador 17 13
3 = 17 22
0 contador 17 24
3 * 17 33
1 2 17 35
4 ; 17 36
4 } 18 9
5 let 21 9 1
0 resultado 21 13
3 = 21 23
0 contador 21 25
3 + 21 34
0 limite 21 36
3 * 21 43
1 2 21 45
4 ; 21 46
5 let 22 9 1
0 division 22 13
3 = 22 22
0 resultado 22 24
3 / 22 34
1 3 22 36
4 ; 22 37
5 let 23 9 1
0 modulo 23 13
3 = 23 20
0 division 23 22
3 % 23 31
1 7 23 33
4 ; 23 34
4 } 24 5
5 for 27 5 8
0 i 27 9
5 in 27 11 9
1 0 27 14
3 . 27 15
3 . 27 16
1 50 27 17
4 { 27 20
5 let 28 9 1
0 cuadrado 28 13
3 = 28 22
0 i 28 24
3 * 28 26
0 i 28 28
4 ; 28 29
5 let 29 9 1
0 cubo 29 13
3 = 29 18
0 cuadrado 29 20
3 * 29 29
0 i 29 31
4 ; 29 32
5 if 31 9 3
0 cubo 31 12
3 > 31 17
1 1000 31 19
4 { 31 24
5 break 32 13 10
4 ; 32 18
4 } 33 9
5 if 35 9 3
0 cuadrado 35 12
3 < 35 21
1 10 35 23
4 { 35 26
5 continue 36 13 11
4 ; 36 21
4 } 37 9
4 } 38 5
5 let 41 5 1
0 fib_resultado 41 9
3 = 41 23
0 fibonacci 41 25
4 ( 41 34
1 20 41 35
4 ) 41 37
4 ; 41 38
5 let 42 5 1
0 factorial_resultado 42 9
3 = 42 29
0 factorial 42 31
4 ( 42 40
1 10 42 41
4 ) 42 43
4 ; 42 44
5 let 43 5 1
0 array_ordenado 43 9
3 = 43 24
0 bubble_sort 43 26
4 ( 43 37
4 ) 43 38
4 ; 43 39
5 let 44 5 1
0 busqueda 44 9
3 = 44 18
0 binary_search 44 20
4 ( 44 33
0 array_ordenado 44 34
4 , 44 48
1 42 44 50
4 ) 44 52
4 ; 44 53
5 let 47 5 1
5 mut 47 9 2
0 suma 47 13
6 : 47 17
0 i32 47 19
3 = 47 23
1 0 47 25
4 ; 47 26
5 let 48 5 1
5 mut 48 9 2
0 producto 48 13
6 : 48 21
0 i32 48 23
3 = 48 27
1 1 48 29
4 ; 48 30
5 let 49 5 1
5 mut 49 9 2
0 promedio 49 13
6 : 49 21
0 f64 49 23
3 = 49 27
1 0.0 49 29
4 ; 49 32
5 let 52 5 1
0 numeros 52 9
3 = 52 17
4 [ 52 19
1 1 52 20
4 , 52 21
1 2 52 23
4 , 52 24
1 3 52 26
4 , 52 27
1 4 52 29
4 , 52 30
1 5 52 32
4 , 52 33
1 6 52 35
4 , 52 36
1 7 52 38
4 , 52 39
1 8 52 41
4 , 52 42
1 9 52 44
4 , 52 45
1 10 52 47
4 ] 52 49
4 ; 52 50
5 let 53 5 1
5 mut 53 9 2
0 indice 53 13
6 : 53 19
0 i32 53 21
3 = 53 25
1 0 53 27
4 ; 53 28
5 while 55 5 6
0 indice 55 11
3 < 55 18
1 10 55 20
4 { 55 23
0 suma 56 9
3 = 56 14
0 suma 56 16
3 + 56 21
0 numeros 56 23
4 [ 56 30
0 indice 56 31
4 ] 56 37
4 ; 56 38
0 producto 57 9
3 = 57 18
0 producto 57 20
3 * 57 29
0 numeros 57 31
4 [ 57 38
0 indice 57 39
4 ] 57 45
4 ; 57 46
0 indice 58 9
3 = 58 16
0 indice 58 18
3 + 58 25
1 1 58 27
4 ; 58 28
4 } 59 5
0 promedio 61 5
3 = 61 14
0 suma 61 16
3 / 61 21
1 10.0 61 23
4 ; 61 27
5 for 64 5 8
0 x 64 9
5 in 64 11 9
1 1 64 14
3 . 64 15
3 . 64 16
1 20 64 17
4 { 64 20
5 for 65 9 8
0 y 65 13
5 in 65 15 9
1 1 65 18
3 . 65 19
3 . 65 20
1 20 65 21
4 { 65 24
5 let 66 13 1
0 multiplicacion 66 17
3 = 66 32
0 x 66 34
3 * 66 36
0 y 66 38
4 ; 66 39
5 if 68 13 3
0 multiplicacion 68 16
3 % 68 31
1 3 68 33
3 == 68 35
1 0 68 38
4 { 68 40
5 if 69 17 3
0 multiplicacion 69 20
3 % 69 35
1 5 69 37
3 == 69 39
1 0 69 42
4 { 69 44
5 let 70 21 1
0 especial 70 25
3 = 70 34
0 multiplicacion 70 36
3 / 70 51
1 15 70 53
4 ; 70 55
4 } 71 17
5 else 71 19 4
4 { 71 24
5 let 72 21 1
0 normal 72 25
3 = 72 32
0 multiplicacion 72 34
3 / 72 49
1 3 72 51
4 ; 72 52
4 } 73 17
4 } 74 13
4 } 75 9
4 } 76 5
5 let 79 5 1
5 mut 79 9 2
0 matriz 79 13
6 : 79 19
0 i32 79 21
3 = 79 25
1 0 79 27
4 ; 79 28
5 let 80 5 1
0 filas 80 9
6 : 80 14
0 i32 80 16
3 = 80 20
1 5 80 22
4 ; 80 23
5 let 81 5 1
0 columnas 81 9
6 : 81 17
0 i32 81 19
3 = 81 23
1 5 81 25
4 ; 81 26
5 for 83 5 8
0 i 83 9
5 in 83 11 9
1 0 83 14
3 . 83 15
3 . 83 16
0 filas 83 17
4 { 83 23
5 for 84 9 8
0 j 84 13
5 in 84 15 9
1 0 84 18
3 . 84 19
3 . 84 20
0 columnas 84 21
4 { 84 30
0 matriz 85 13
3 = 85 20
0 i 85 22
3 * 85 24
0 columnas 85 26
3 + 85 35
0 j 85 37
4 ; 85 38
5 let 86 13 1
0 valor 86 17
3 = 86 23
0 matriz 86 25
3 * 86 32
1 2 86 34
3 + 86 36
1 1 86 38
4 ; 86 39
4 } 87 9
4 } 88 5
5 let 91 5 1
0 cadena1 91 9
6 : 91 16
0 str 91 18
3 = 91 22
2 "Hola" 91 24
4 ; 91 30
5 let 92 5 1
0 cadena2 92 9
6 : 92 16
0 str 92 18
3 = 92 22
2 "Mundo" 92 24
4 ; 92 31
5 let 93 5 1
0 longitud1 93 9
3 = 93 19
0 len 93 21
4 ( 93 24
0 cadena1 93 25
4 ) 93 32
4 ; 93 33
5 let 94 5 1
0 longitud2 94 9
3 = 94 19
0 len 94 21
4 ( 94 24
0 cadena2 94 25
4 ) 94 32
4 ; 94 33
5 match 97 5 5
0 contador 97 11
4 { 97 20
1 0 98 9
3 = 98 11
3 > 98 12
5 let 98 14 1
0 cero 98 18
3 = 98 23
5 true 98 25 13
4 , 98 29
1 1 99 9
3 = 99 11
3 > 99 12
5 let 99 14 1
0 uno 99 18
3 = 99 22
5 true 99 24 13
4 , 99 28
1 2 100 9
3 = 100 11
3 > 100 12
5 let 100 14 1
0 dos 100 18
3 = 100 22
5 true 100 24 13
4 , 100 28
0 _ 101 9
3 = 101 11
3 > 101 12
5 let 101 14 1
0 otro 101 18
3 = 101 23
5 true 101 25 13
4 , 101 29
4 } 102 5
5 loop 105 5 7
4 { 105 10
0 contador 106 9
3 = 106 18
0 contador 106 20
3 - 106 29
1 1 106 31
4 ; 106 32
5 if 108 9 3
0 contador 108 12
3 <= 108 21
1 0 108 24
4 { 108 26
5 break 109 13 10
4 ; 109 18
4 } 110 9
5 let 112 9 1
0 temporal 112 13
3 = 112 22
0 contador 112 24
3 * 112 33
1 3 112 35
4 ; 112 36
5 if 114 9 3
0 temporal 114 12
3 > 114 21
1 200 114 23
4 { 114 27
5 continue 115 13 11
4 ; 115 21
4 } 116 9
4 } 117 5
5 let 120 5 1
0 resultado_complejo 120 9
3 = 120 28
0 calcular_complejo 120 30
4 ( 120 47
4 ) 120 48
4 ; 120 49
5 let 121 5 1
5 mut 121 9 2
0 acumulador 121 13
6 : 121 23
0 f64 121 25
3 = 121 29
1 0.0 121 31
4 ; 121 34
5 let 122 5 1
0 precision 122 9
6 : 122 18
0 f64 122 20
3 = 122 24
1 0.001 122 26
4 ; 122 31
5 for 125 5 8
0 iteracion 125 9
5 in 125 19 9
1 1 125 22
3 . 125 23
3 . 125 24
1 100 125 25
4 { 125 29
5 let 126 9 1
0 valor_actual 126 13
3 = 126 26
0 iteracion 126 28
3 * 126 38
0 pi 126 40
4 ; 126 42
0 acumulador 127 9
3 = 127 20
0 acumulador 127 22
3 + 127 33
0 valor_actual 127 35
4 ; 127 47
5 if 129 9 3
0 acumulador 129 12
3 > 129 23
1 1000.0 129 25
4 { 129 32
5 let 130 13 1
0 diferencia 130 17
3 = 130 28
0 acumulador 130 30
3 - 130 41
1 1000.0 130 43
4 ; 130 49
5 if 132 13 3
0 diferencia 132 16
3 < 132 27
0 precision 132 29
4 { 132 39
5 break 133 17 10
4 ; 133 22
4 } 134 13
4 } 135 9
4 } 136 5
4 } 137 1
5 fn 139 1 0
0 fibonacci 139 4
4 ( 139 13
0 n 139 14
6 : 139 15
0 i32 139 17
4 ) 139 20
3 - 139 22
3 > 139 23
0 i32 139 25
4 { 139 29
5 if 140 5 3
0 n 140 8
3 <= 140 10
1 1 140 13
4 { 140 15
5 return 141 9 12
0 n 141 16
4 ; 141 17
4 } 142 5
5 let 144 5 1
5 mut 144 9 2
0 a 144 13
6 : 144 14
0 i32 144 16
3 = 144 20
1 0 144 22
4 ; 144 23
5 let 145 5 1
5 mut 145 9 2
0 b 145 13
6 : 145 14
0 i32 145 16
3 = 145 20
1 1 145 22
4 ; 145 23
5 let 146 5 1
5 mut 146 9 2
0 temp 146 13
6 : 146 17
0 i32 146 19
3 = 146 23
1 0 146 25
4 ; 146 26
5 for 148 5 8
0 i 148 9
5 in 148 11 9
1 2 148 14
3 . 148 15
3 . 148 16
0 n 148 17
3 + 148 18
1 1 148 19
4 { 148 21
0 temp 149 9
3 = 149 14
0 a 149 16
3 + 149 18
0 b 149 20
4 ; 149 21
0 a 150 9
3 = 150 11
0 b 150 13
4 ; 150 14
0 b 151 9
3 = 151 11
0 temp 151 13
4 ; 151 17
4 } 152 5
5 return 154 5 12
0 b 154 12
4 ; 154 13
4 } 155 1
5 fn 157 1 0
0 factorial 157 4
4 ( 157 13
0 n 157 14
6 : 157 15
0 i32 157 17
4 ) 157 20
3 - 157 22
3 > 157 23
0 i32 157 25
4 { 157 29
5 if 158 5 3
0 n 158 8
3 <= 158 10
1 1 158 13
4 { 158 15
5 return 159 9 12
1 1 159 16
4 ; 159 17
4 } 160 5
5 let 162 5 1
5 mut 162 9 2
0 resultado 162 13
6 : 162 22
0 i32 162 24
3 = 162 28
1 1 162 30
4 ; 162 31
5 let 163 5 1
5 mut 163 9 2
0 i 163 13
6 : 163 14
0 i32 163 16
3 = 163 20
1 2 163 22
4 ; 163 23
5 while 165 5 6
0 i 165 11
3 <= 165 13
0 n 165 16
4 { 165 18
0 resultado 166 9
3 = 166 19
0 resultado 166 21
3 * 166 31
0 i 166 33
4 ; 166 34
0 i 167 9
3 = 167 11
0 i 167 13
3 + 167 15
1 1 167 17
4 ; 167 18
4 } 168 5
5 return 170 5 12
0 resultado 170 12
4 ; 170 21
4 } 171 1
5 fn 173 1 0
0 bubble_sort 173 4
4 ( 173 15
4 ) 173 16
3 - 173 18
3 > 173 19
0 i32 173 21
4 { 173 25
5 let 174 5 1
5 mut 174 9 2
0 arr 174 13
3 = 174 17
4 [ 174 19
1 64 174 20
4 , 174 22
1 34 174 24
4 , 174 26
1 25 174 28
4 , 174 30
1 12 174 32
4 , 174 34
1 22 174 36
4 , 174 38
1 11 174 40
4 , 174 42
1 90 174 44
4 ] 174 46
4 ; 174 47
5 let 175 5 1
0 n 175 9
6 : 175 10
0 i32 175 12
3 = 175 16
1 7 175 18
4 ; 175 19
5 for 177 5 8
0 i 177 9
5 in 177 11 9
1 0 177 14
3 . 177 15
3 . 177 16
0 n 177 17
3 - 177 18
1 1 177 19
4 { 177 21
5 for 178 9 8
0 j 178 13
5 in 178 15 9
1 0 178 18
3 . 178 19
3 . 178 20
0 n 178 21
3 - 178 22
0 i 178 23
3 - 178 24
1 1 178 25
4 { 178 27
5 if 179 13 3
0 arr 179 16
4 [ 179 19
0 j 179 20
4 ] 179 21
3 > 179 23
0 arr 179 25
4 [ 179 28
0 j 179 29
3 + 179 30
1 1 179 31
4 ] 179 32
4 { 179 34
5 let 180 17 1
0 temp 180 21
3 = 180 26
0 arr 180 28
4 [ 180 31
0 j 180 32
4 ] 180 33
4 ; 180 34
0 arr 181 17
4 [ 181 20
0 j 181 21
4 ] 181 22
3 = 181 24
0 arr 181 26
4 [ 181 29
0 j 181 30
3 + 181 31
1 1 181 32
4 ] 181 33
4 ; 181 34
0 arr 182 17
4 [ 182 20
0 j 182 21
3 + 182 22
1 1 182 23
4 ] 182 24
3 = 182 26
0 temp 182 28
4 ; 182 32
4 } 183 13
4 } 184 9
4 } 185 5
5 return 187 5 12
1 0 187 12
4 ; 187 13
4 } 188 1
5 fn 190 1 0
0 binary_search 190 4
4 ( 190 17
0 arr 190 18
6 : 190 21
0 i32 190 23
4 , 190 26
0 target 190 28
6 : 190 34
0 i32 190 36
4 ) 190 39
3 - 190 41
3 > 190 42
0 i32 190 44
4 { 190 48
5 let 191 5 1
5 mut 191 9 2
0 left 191 13
6 : 191 17
0 i32 191 19
3 = 191 23
1 0 191 25
4 ; 191 26
5 let 192 5 1
5 mut 192 9 2
0 right 192 13
6 : 192 18
0 i32 192 20
3 = 192 24
1 9 192 26
4 ; 192 27
5 while 194 5 6
0 left 194 11
3 <= 194 16
0 right 194 19
4 { 194 25
5 let 195 9 1
0 mid 195 13
3 = 195 17
0 left 195 19
3 + 195 24
4 ( 195 26
0 right 195 27
3 - 195 33
0 left 195 35
4 ) 195 39
3 / 195 41
1 2 195 43
4 ; 195 44
5 if 197 9 3
0 arr 197 12
3 == 197 16
0 target 197 19
4 { 197 26
5 return 198 13 12
0 mid 198 20
4 ; 198 23
4 } 199 9
7 EOF 201 1

# Total de tokens: 833
