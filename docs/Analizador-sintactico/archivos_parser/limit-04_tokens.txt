# Tokens generados desde: docs/Analizador-Lexico/examples/limit-04.txt
# Formato: tipo_token lexema linea columna [indice_palabra_clave]
# Tipos: IDENTIFIER=0, NUMBER=1, STRING=2, OPERATOR=3, DELIMITER=4, KEYWORD=5, UNKNOWN=6, EOF=7
# Palabras clave: fn=0, let=1, mut=2, if=3, else=4, match=5, while=6, loop=7, for=8, in=9, break=10, continue=11, return=12, true=13, false=14

6 @ 4 1
5 fn 4 2 0
0 main 4 5
4 ( 4 9
4 ) 4 10
4 { 4 12
6 # 4 13
5 let 6 5 1
5 mut 6 9 2
0 contador 6 13
6 : 6 21
0 i32 6 23
3 = 6 27
1 0 6 29
4 ; 6 30
5 let 7 5 1
0 limite 7 9
6 : 7 15
0 i32 7 17
3 = 7 21
1 100 7 23
4 ; 7 26
5 let 8 5 1
0 pi 8 9
6 : 8 11
0 f64 8 13
3 = 8 17
1 3.14159 8 19
4 ; 8 26
5 let 9 5 1
0 nombre 9 9
6 : 9 15
0 str 9 17
3 = 9 21
2 "Analizador Léxico" 9 23
4 ; 9 43
5 let 10 5 1
0 activo 10 9
6 : 10 15
0 bool 10 17
3 = 10 22
5 true 10 24 13
4 ; 10 28
5 while 13 5 6
0 contador 13 11
3 < 13 20
0 limite 13 22
4 { 13 29
5 if 14 9 3
0 contador 14 12
3 % 14 21
1 2 14 23
3 == 14 25
1 0 14 28
4 { 14 30
0 contador 15 13
3 = 15 22
0 contador 15 24
3 + 15 33
1 1 15 35
4 ; 15 36
4 } 16 9
5 else 16 11 4
4 { 16 16
0 contador 17 13
3 = 17 22
0 contador 17 24
3 * 17 33
1 2 17 35
4 ; 17 36
4 } 18 9
5 let 21 9 1
0 resultado 21 13
3 = 21 23
0 contador 21 25
3 + 21 34
0 limite 21 36
3 * 21 43
1 2 21 45
4 ; 21 46
5 let 22 9 1
0 division 22 13
3 = 22 22
0 resultado 22 24
3 / 22 34
1 3 22 36
4 ; 22 37
5 let 23 9 1
0 modulo 23 13
3 = 23 20
0 division 23 22
3 % 23 31
1 7 23 33
4 ; 23 34
4 } 24 5
5 for 27 5 8
0 i 27 9
5 in 27 11 9
1 0 27 14
3 . 27 15
3 . 27 16
1 50 27 17
4 { 27 20
5 let 28 9 1
0 cuadrado 28 13
3 = 28 22
0 i 28 24
3 * 28 26
0 i 28 28
4 ; 28 29
5 let 29 9 1
0 cubo 29 13
3 = 29 18
0 cuadrado 29 20
3 * 29 29
0 i 29 31
4 ; 29 32
5 if 31 9 3
0 cubo 31 12
3 > 31 17
1 1000 31 19
4 { 31 24
5 break 32 13 10
4 ; 32 18
4 } 33 9
5 if 35 9 3
0 cuadrado 35 12
3 < 35 21
1 10 35 23
4 { 35 26
5 continue 36 13 11
4 ; 36 21
4 } 37 9
4 } 38 5
5 let 41 5 1
0 fib_resultado 41 9
3 = 41 23
0 fibonacci 41 25
4 ( 41 34
1 20 41 35
4 ) 41 37
4 ; 41 38
5 let 42 5 1
0 factorial_resultado 42 9
3 = 42 29
0 factorial 42 31
4 ( 42 40
1 10 42 41
4 ) 42 43
4 ; 42 44
5 let 43 5 1
0 array_ordenado 43 9
3 = 43 24
0 bubble_sort 43 26
4 ( 43 37
4 ) 43 38
4 ; 43 39
5 let 44 5 1
0 busqueda 44 9
3 = 44 18
0 binary_search 44 20
4 ( 44 33
0 array_ordenado 44 34
4 , 44 48
1 42 44 50
4 ) 44 52
4 ; 44 53
5 let 47 5 1
5 mut 47 9 2
0 suma 47 13
6 : 47 17
0 i32 47 19
3 = 47 23
1 0 47 25
4 ; 47 26
5 let 48 5 1
5 mut 48 9 2
0 producto 48 13
6 : 48 21
0 i32 48 23
3 = 48 27
1 1 48 29
4 ; 48 30
5 let 49 5 1
5 mut 49 9 2
0 promedio 49 13
6 : 49 21
0 f64 49 23
3 = 49 27
1 0.0 49 29
4 ; 49 32
5 let 52 5 1
0 numeros 52 9
3 = 52 17
4 [ 52 19
1 1 52 20
4 , 52 21
1 2 52 23
4 , 52 24
1 3 52 26
4 , 52 27
1 4 52 29
4 , 52 30
1 5 52 32
4 , 52 33
1 6 52 35
4 , 52 36
1 7 52 38
4 , 52 39
1 8 52 41
4 , 52 42
1 9 52 44
4 , 52 45
1 10 52 47
4 ] 52 49
4 ; 52 50
5 let 53 5 1
5 mut 53 9 2
0 indice 53 13
6 : 53 19
0 i32 53 21
3 = 53 25
1 0 53 27
4 ; 53 28
5 while 55 5 6
0 indice 55 11
3 < 55 18
1 10 55 20
4 { 55 23
0 suma 56 9
3 = 56 14
0 suma 56 16
3 + 56 21
0 numeros 56 23
4 [ 56 30
0 indice 56 31
4 ] 56 37
4 ; 56 38
0 producto 57 9
3 = 57 18
0 producto 57 20
3 * 57 29
0 numeros 57 31
4 [ 57 38
0 indice 57 39
4 ] 57 45
4 ; 57 46
0 indice 58 9
3 = 58 16
0 indice 58 18
3 + 58 25
1 1 58 27
4 ; 58 28
4 } 59 5
0 promedio 61 5
3 = 61 14
0 suma 61 16
3 / 61 21
1 10.0 61 23
4 ; 61 27
5 for 64 5 8
0 x 64 9
5 in 64 11 9
1 1 64 14
3 . 64 15
3 . 64 16
1 20 64 17
4 { 64 20
5 for 65 9 8
0 y 65 13
5 in 65 15 9
1 1 65 18
3 . 65 19
3 . 65 20
1 20 65 21
4 { 65 24
5 let 66 13 1
0 multiplicacion 66 17
3 = 66 32
0 x 66 34
3 * 66 36
0 y 66 38
4 ; 66 39
5 if 68 13 3
0 multiplicacion 68 16
3 % 68 31
1 3 68 33
3 == 68 35
1 0 68 38
4 { 68 40
5 if 69 17 3
0 multiplicacion 69 20
3 % 69 35
1 5 69 37
3 == 69 39
1 0 69 42
4 { 69 44
5 let 70 21 1
0 especial 70 25
3 = 70 34
0 multiplicacion 70 36
3 / 70 51
1 15 70 53
4 ; 70 55
4 } 71 17
5 else 71 19 4
4 { 71 24
5 let 72 21 1
0 normal 72 25
3 = 72 32
0 multiplicacion 72 34
3 / 72 49
1 3 72 51
4 ; 72 52
4 } 73 17
4 } 74 13
4 } 75 9
4 } 76 5
5 let 79 5 1
5 mut 79 9 2
0 matriz 79 13
6 : 79 19
0 i32 79 21
3 = 79 25
1 0 79 27
4 ; 79 28
5 let 80 5 1
0 filas 80 9
6 : 80 14
0 i32 80 16
3 = 80 20
1 5 80 22
4 ; 80 23
5 let 81 5 1
0 columnas 81 9
6 : 81 17
0 i32 81 19
3 = 81 23
1 5 81 25
4 ; 81 26
5 for 83 5 8
0 i 83 9
5 in 83 11 9
1 0 83 14
3 . 83 15
3 . 83 16
0 filas 83 17
4 { 83 23
5 for 84 9 8
0 j 84 13
5 in 84 15 9
1 0 84 18
3 . 84 19
3 . 84 20
0 columnas 84 21
4 { 84 30
0 matriz 85 13
3 = 85 20
0 i 85 22
3 * 85 24
0 columnas 85 26
3 + 85 35
0 j 85 37
4 ; 85 38
5 let 86 13 1
0 valor 86 17
3 = 86 23
0 matriz 86 25
3 * 86 32
1 2 86 34
3 + 86 36
1 1 86 38
4 ; 86 39
4 } 87 9
4 } 88 5
5 let 91 5 1
0 cadena1 91 9
6 : 91 16
0 str 91 18
3 = 91 22
2 "Hola" 91 24
4 ; 91 30
5 let 92 5 1
0 cadena2 92 9
6 : 92 16
0 str 92 18
3 = 92 22
2 "Mundo" 92 24
4 ; 92 31
5 let 93 5 1
0 longitud1 93 9
3 = 93 19
0 len 93 21
4 ( 93 24
0 cadena1 93 25
4 ) 93 32
4 ; 93 33
5 let 94 5 1
0 longitud2 94 9
3 = 94 19
0 len 94 21
4 ( 94 24
0 cadena2 94 25
4 ) 94 32
4 ; 94 33
5 match 97 5 5
0 contador 97 11
4 { 97 20
1 0 98 9
3 = 98 11
3 > 98 12
5 let 98 14 1
0 cero 98 18
3 = 98 23
5 true 98 25 13
4 , 98 29
1 1 99 9
3 = 99 11
3 > 99 12
5 let 99 14 1
0 uno 99 18
3 = 99 22
5 true 99 24 13
4 , 99 28
1 2 100 9
3 = 100 11
3 > 100 12
5 let 100 14 1
0 dos 100 18
3 = 100 22
5 true 100 24 13
4 , 100 28
0 _ 101 9
3 = 101 11
3 > 101 12
5 let 101 14 1
0 otro 101 18
3 = 101 23
5 true 101 25 13
4 , 101 29
4 } 102 5
5 loop 105 5 7
4 { 105 10
0 contador 106 9
3 = 106 18
0 contador 106 20
3 - 106 29
1 1 106 31
4 ; 106 32
5 if 108 9 3
0 contador 108 12
3 <= 108 21
1 0 108 24
4 { 108 26
5 break 109 13 10
4 ; 109 18
4 } 110 9
5 let 112 9 1
0 temporal 112 13
3 = 112 22
0 contador 112 24
3 * 112 33
1 3 112 35
4 ; 112 36
5 if 114 9 3
0 temporal 114 12
3 > 114 21
1 200 114 23
4 { 114 27
5 continue 115 13 11
4 ; 115 21
4 } 116 9
4 } 117 5
5 let 120 5 1
0 resultado_complejo 120 9
3 = 120 28
0 calcular_complejo 120 30
4 ( 120 47
4 ) 120 48
4 ; 120 49
5 let 121 5 1
5 mut 121 9 2
0 acumulador 121 13
6 : 121 23
0 f64 121 25
3 = 121 29
1 0.0 121 31
4 ; 121 34
5 let 122 5 1
0 precision 122 9
6 : 122 18
0 f64 122 20
3 = 122 24
1 0.001 122 26
4 ; 122 31
5 for 125 5 8
0 iteracion 125 9
5 in 125 19 9
1 1 125 22
3 . 125 23
3 . 125 24
1 100 125 25
4 { 125 29
5 let 126 9 1
0 valor_actual 126 13
3 = 126 26
0 iteracion 126 28
3 * 126 38
0 pi 126 40
4 ; 126 42
0 acumulador 127 9
3 = 127 20
0 acumulador 127 22
3 + 127 33
0 valor_actual 127 35
4 ; 127 47
5 if 129 9 3
0 acumulador 129 12
3 > 129 23
1 1000.0 129 25
4 { 129 32
5 let 130 13 1
0 diferencia 130 17
3 = 130 28
0 acumulador 130 30
3 - 130 41
1 1000.0 130 43
4 ; 130 49
5 if 132 13 3
0 diferencia 132 16
3 < 132 27
0 precision 132 29
4 { 132 39
5 break 133 17 10
4 ; 133 22
4 } 134 13
4 } 135 9
4 } 136 5
4 } 137 1
5 fn 139 1 0
0 fibonacci 139 4
4 ( 139 13
0 n 139 14
6 : 139 15
0 i32 139 17
4 ) 139 20
3 - 139 22
3 > 139 23
0 i32 139 25
4 { 139 29
5 if 140 5 3
0 n 140 8
3 <= 140 10
1 1 140 13
4 { 140 15
5 return 141 9 12
0 n 141 16
4 ; 141 17
4 } 142 5
5 let 144 5 1
5 mut 144 9 2
0 a 144 13
6 : 144 14
0 i32 144 16
3 = 144 20
1 0 144 22
4 ; 144 23
5 let 145 5 1
5 mut 145 9 2
0 b 145 13
6 : 145 14
0 i32 145 16
3 = 145 20
1 1 145 22
4 ; 145 23
5 let 146 5 1
5 mut 146 9 2
0 temp 146 13
6 : 146 17
0 i32 146 19
3 = 146 23
1 0 146 25
4 ; 146 26
5 for 148 5 8
0 i 148 9
5 in 148 11 9
1 2 148 14
3 . 148 15
3 . 148 16
0 n 148 17
3 + 148 18
1 1 148 19
4 { 148 21
0 temp 149 9
3 = 149 14
0 a 149 16
3 + 149 18
0 b 149 20
4 ; 149 21
0 a 150 9
3 = 150 11
0 b 150 13
4 ; 150 14
0 b 151 9
3 = 151 11
0 temp 151 13
4 ; 151 17
4 } 152 5
5 return 154 5 12
0 b 154 12
4 ; 154 13
4 } 155 1
5 fn 157 1 0
0 factorial 157 4
4 ( 157 13
0 n 157 14
6 : 157 15
0 i32 157 17
4 ) 157 20
3 - 157 22
3 > 157 23
0 i32 157 25
4 { 157 29
5 if 158 5 3
0 n 158 8
3 <= 158 10
1 1 158 13
4 { 158 15
5 return 159 9 12
1 1 159 16
4 ; 159 17
4 } 160 5
5 let 162 5 1
5 mut 162 9 2
0 resultado 162 13
6 : 162 22
0 i32 162 24
3 = 162 28
1 1 162 30
4 ; 162 31
5 let 163 5 1
5 mut 163 9 2
0 i 163 13
6 : 163 14
0 i32 163 16
3 = 163 20
1 2 163 22
4 ; 163 23
5 while 165 5 6
0 i 165 11
3 <= 165 13
0 n 165 16
4 { 165 18
0 resultado 166 9
3 = 166 19
0 resultado 166 21
3 * 166 31
0 i 166 33
4 ; 166 34
0 i 167 9
3 = 167 11
0 i 167 13
3 + 167 15
1 1 167 17
4 ; 167 18
4 } 168 5
5 return 170 5 12
0 resultado 170 12
4 ; 170 21
4 } 171 1
5 fn 173 1 0
0 bubble_sort 173 4
4 ( 173 15
4 ) 173 16
3 - 173 18
3 > 173 19
0 i32 173 21
4 { 173 25
5 let 174 5 1
5 mut 174 9 2
0 arr 174 13
3 = 174 17
4 [ 174 19
1 64 174 20
4 , 174 22
1 34 174 24
4 , 174 26
1 25 174 28
4 , 174 30
1 12 174 32
4 , 174 34
1 22 174 36
4 , 174 38
1 11 174 40
4 , 174 42
1 90 174 44
4 ] 174 46
4 ; 174 47
5 let 175 5 1
0 n 175 9
6 : 175 10
0 i32 175 12
3 = 175 16
1 7 175 18
4 ; 175 19
5 for 177 5 8
0 i 177 9
5 in 177 11 9
1 0 177 14
3 . 177 15
3 . 177 16
0 n 177 17
3 - 177 18
1 1 177 19
4 { 177 21
5 for 178 9 8
0 j 178 13
5 in 178 15 9
1 0 178 18
3 . 178 19
3 . 178 20
0 n 178 21
3 - 178 22
0 i 178 23
3 - 178 24
1 1 178 25
4 { 178 27
5 if 179 13 3
0 arr 179 16
4 [ 179 19
0 j 179 20
4 ] 179 21
3 > 179 23
0 arr 179 25
4 [ 179 28
0 j 179 29
3 + 179 30
1 1 179 31
4 ] 179 32
4 { 179 34
5 let 180 17 1
0 temp 180 21
3 = 180 26
0 arr 180 28
4 [ 180 31
0 j 180 32
4 ] 180 33
4 ; 180 34
0 arr 181 17
4 [ 181 20
0 j 181 21
4 ] 181 22
3 = 181 24
0 arr 181 26
4 [ 181 29
0 j 181 30
3 + 181 31
1 1 181 32
4 ] 181 33
4 ; 181 34
0 arr 182 17
4 [ 182 20
0 j 182 21
3 + 182 22
1 1 182 23
4 ] 182 24
3 = 182 26
0 temp 182 28
4 ; 182 32
4 } 183 13
4 } 184 9
4 } 185 5
5 return 187 5 12
1 0 187 12
4 ; 187 13
4 } 188 1
5 fn 190 1 0
0 binary_search 190 4
4 ( 190 17
0 arr 190 18
6 : 190 21
0 i32 190 23
4 , 190 26
0 target 190 28
6 : 190 34
0 i32 190 36
4 ) 190 39
3 - 190 41
3 > 190 42
0 i32 190 44
4 { 190 48
5 let 191 5 1
5 mut 191 9 2
0 left 191 13
6 : 191 17
0 i32 191 19
3 = 191 23
1 0 191 25
4 ; 191 26
5 let 192 5 1
5 mut 192 9 2
0 right 192 13
6 : 192 18
0 i32 192 20
3 = 192 24
1 9 192 26
4 ; 192 27
5 while 194 5 6
0 left 194 11
3 <= 194 16
0 right 194 19
4 { 194 25
5 let 195 9 1
0 mid 195 13
3 = 195 17
0 left 195 19
3 + 195 24
4 ( 195 26
0 right 195 27
3 - 195 33
0 left 195 35
4 ) 195 39
3 / 195 41
1 2 195 43
4 ; 195 44
5 if 197 9 3
0 arr 197 12
3 == 197 16
0 target 197 19
4 { 197 26
5 return 198 13 12
0 mid 198 20
4 ; 198 23
4 } 199 9
5 fn 204 1 0
0 main 204 4
4 ( 204 8
4 ) 204 9
4 { 204 11
5 let 206 5 1
5 mut 206 9 2
0 contador 206 13
6 : 206 21
0 i32 206 23
3 = 206 27
1 0 206 29
4 ; 206 30
5 let 207 5 1
0 limite 207 9
6 : 207 15
0 i32 207 17
3 = 207 21
1 100 207 23
4 ; 207 26
5 let 208 5 1
0 pi 208 9
6 : 208 11
0 f64 208 13
3 = 208 17
1 3.14159 208 19
4 ; 208 26
5 let 209 5 1
0 nombre 209 9
6 : 209 15
0 str 209 17
3 = 209 21
2 "Analizador Léxico" 209 23
4 ; 209 43
5 let 210 5 1
0 activo 210 9
6 : 210 15
0 bool 210 17
3 = 210 22
5 true 210 24 13
4 ; 210 28
5 while 213 5 6
0 contador 213 11
3 < 213 20
0 limite 213 22
4 { 213 29
5 if 214 9 3
0 contador 214 12
3 % 214 21
1 2 214 23
3 == 214 25
1 0 214 28
4 { 214 30
0 contador 215 13
3 = 215 22
0 contador 215 24
3 + 215 33
1 1 215 35
4 ; 215 36
4 } 216 9
5 else 216 11 4
4 { 216 16
0 contador 217 13
3 = 217 22
0 contador 217 24
3 * 217 33
1 2 217 35
4 ; 217 36
4 } 218 9
5 let 221 9 1
0 resultado 221 13
3 = 221 23
0 contador 221 25
3 + 221 34
0 limite 221 36
3 * 221 43
1 2 221 45
4 ; 221 46
5 let 222 9 1
0 division 222 13
3 = 222 22
0 resultado 222 24
3 / 222 34
1 3 222 36
4 ; 222 37
5 let 223 9 1
0 modulo 223 13
3 = 223 20
0 division 223 22
3 % 223 31
1 7 223 33
4 ; 223 34
4 } 224 5
5 for 227 5 8
0 i 227 9
5 in 227 11 9
1 0 227 14
3 . 227 15
3 . 227 16
1 50 227 17
4 { 227 20
5 let 228 9 1
0 cuadrado 228 13
3 = 228 22
0 i 228 24
3 * 228 26
0 i 228 28
4 ; 228 29
5 let 229 9 1
0 cubo 229 13
3 = 229 18
0 cuadrado 229 20
3 * 229 29
0 i 229 31
4 ; 229 32
5 if 231 9 3
0 cubo 231 12
3 > 231 17
1 1000 231 19
4 { 231 24
5 break 232 13 10
4 ; 232 18
4 } 233 9
5 if 235 9 3
0 cuadrado 235 12
3 < 235 21
1 10 235 23
4 { 235 26
5 continue 236 13 11
4 ; 236 21
4 } 237 9
4 } 238 5
5 let 241 5 1
0 fib_resultado 241 9
3 = 241 23
0 fibonacci 241 25
4 ( 241 34
1 20 241 35
4 ) 241 37
4 ; 241 38
5 let 242 5 1
0 factorial_resultado 242 9
3 = 242 29
0 factorial 242 31
4 ( 242 40
1 10 242 41
4 ) 242 43
4 ; 242 44
5 let 243 5 1
0 array_ordenado 243 9
3 = 243 24
0 bubble_sort 243 26
4 ( 243 37
4 ) 243 38
4 ; 243 39
5 let 244 5 1
0 busqueda 244 9
3 = 244 18
0 binary_search 244 20
4 ( 244 33
0 array_ordenado 244 34
4 , 244 48
1 42 244 50
4 ) 244 52
4 ; 244 53
5 let 247 5 1
5 mut 247 9 2
0 suma 247 13
6 : 247 17
0 i32 247 19
3 = 247 23
1 0 247 25
4 ; 247 26
5 let 248 5 1
5 mut 248 9 2
0 producto 248 13
6 : 248 21
0 i32 248 23
3 = 248 27
1 1 248 29
4 ; 248 30
5 let 249 5 1
5 mut 249 9 2
0 promedio 249 13
6 : 249 21
0 f64 249 23
3 = 249 27
1 0.0 249 29
4 ; 249 32
5 let 252 5 1
0 numeros 252 9
3 = 252 17
4 [ 252 19
1 1 252 20
4 , 252 21
1 2 252 23
4 , 252 24
1 3 252 26
4 , 252 27
1 4 252 29
4 , 252 30
1 5 252 32
4 , 252 33
1 6 252 35
4 , 252 36
1 7 252 38
4 , 252 39
1 8 252 41
4 , 252 42
1 9 252 44
4 , 252 45
1 10 252 47
4 ] 252 49
4 ; 252 50
5 let 253 5 1
5 mut 253 9 2
0 indice 253 13
6 : 253 19
0 i32 253 21
3 = 253 25
1 0 253 27
4 ; 253 28
5 while 255 5 6
0 indice 255 11
3 < 255 18
1 10 255 20
4 { 255 23
0 suma 256 9
3 = 256 14
0 suma 256 16
3 + 256 21
0 numeros 256 23
4 [ 256 30
0 indice 256 31
4 ] 256 37
4 ; 256 38
0 producto 257 9
3 = 257 18
0 producto 257 20
3 * 257 29
0 numeros 257 31
4 [ 257 38
0 indice 257 39
4 ] 257 45
4 ; 257 46
0 indice 258 9
3 = 258 16
0 indice 258 18
3 + 258 25
1 1 258 27
4 ; 258 28
4 } 259 5
0 promedio 261 5
3 = 261 14
0 suma 261 16
3 / 261 21
1 10.0 261 23
4 ; 261 27
5 for 264 5 8
0 x 264 9
5 in 264 11 9
1 1 264 14
3 . 264 15
3 . 264 16
1 20 264 17
4 { 264 20
5 for 265 9 8
0 y 265 13
5 in 265 15 9
1 1 265 18
3 . 265 19
3 . 265 20
1 20 265 21
4 { 265 24
5 let 266 13 1
0 multiplicacion 266 17
3 = 266 32
0 x 266 34
3 * 266 36
0 y 266 38
4 ; 266 39
5 if 268 13 3
0 multiplicacion 268 16
3 % 268 31
1 3 268 33
3 == 268 35
1 0 268 38
4 { 268 40
5 if 269 17 3
0 multiplicacion 269 20
3 % 269 35
1 5 269 37
3 == 269 39
1 0 269 42
4 { 269 44
5 let 270 21 1
0 especial 270 25
3 = 270 34
0 multiplicacion 270 36
3 / 270 51
1 15 270 53
4 ; 270 55
4 } 271 17
5 else 271 19 4
4 { 271 24
5 let 272 21 1
0 normal 272 25
3 = 272 32
0 multiplicacion 272 34
3 / 272 49
1 3 272 51
4 ; 272 52
4 } 273 17
4 } 274 13
4 } 275 9
4 } 276 5
5 let 279 5 1
5 mut 279 9 2
0 matriz 279 13
6 : 279 19
0 i32 279 21
3 = 279 25
1 0 279 27
4 ; 279 28
5 let 280 5 1
0 filas 280 9
6 : 280 14
0 i32 280 16
3 = 280 20
1 5 280 22
4 ; 280 23
5 let 281 5 1
0 columnas 281 9
6 : 281 17
0 i32 281 19
3 = 281 23
1 5 281 25
4 ; 281 26
5 for 283 5 8
0 i 283 9
5 in 283 11 9
1 0 283 14
3 . 283 15
3 . 283 16
0 filas 283 17
4 { 283 23
5 for 284 9 8
0 j 284 13
5 in 284 15 9
1 0 284 18
3 . 284 19
3 . 284 20
0 columnas 284 21
4 { 284 30
0 matriz 285 13
3 = 285 20
0 i 285 22
3 * 285 24
0 columnas 285 26
3 + 285 35
0 j 285 37
4 ; 285 38
5 let 286 13 1
0 valor 286 17
3 = 286 23
0 matriz 286 25
3 * 286 32
1 2 286 34
3 + 286 36
1 1 286 38
4 ; 286 39
4 } 287 9
4 } 288 5
5 let 291 5 1
0 cadena1 291 9
6 : 291 16
0 str 291 18
3 = 291 22
2 "Hola" 291 24
4 ; 291 30
5 let 292 5 1
0 cadena2 292 9
6 : 292 16
0 str 292 18
3 = 292 22
2 "Mundo" 292 24
4 ; 292 31
5 let 293 5 1
0 longitud1 293 9
3 = 293 19
0 len 293 21
4 ( 293 24
0 cadena1 293 25
4 ) 293 32
4 ; 293 33
5 let 294 5 1
0 longitud2 294 9
3 = 294 19
0 len 294 21
4 ( 294 24
0 cadena2 294 25
4 ) 294 32
4 ; 294 33
5 match 297 5 5
0 contador 297 11
4 { 297 20
1 0 298 9
3 = 298 11
3 > 298 12
5 let 298 14 1
0 cero 298 18
3 = 298 23
5 true 298 25 13
4 , 298 29
1 1 299 9
3 = 299 11
3 > 299 12
5 let 299 14 1
0 uno 299 18
3 = 299 22
5 true 299 24 13
4 , 299 28
1 2 300 9
3 = 300 11
3 > 300 12
5 let 300 14 1
0 dos 300 18
3 = 300 22
5 true 300 24 13
4 , 300 28
0 _ 301 9
3 = 301 11
3 > 301 12
5 let 301 14 1
0 otro 301 18
3 = 301 23
5 true 301 25 13
4 , 301 29
4 } 302 5
5 loop 305 5 7
4 { 305 10
0 contador 306 9
3 = 306 18
0 contador 306 20
3 - 306 29
1 1 306 31
4 ; 306 32
5 if 308 9 3
0 contador 308 12
3 <= 308 21
1 0 308 24
4 { 308 26
5 break 309 13 10
4 ; 309 18
4 } 310 9
5 let 312 9 1
0 temporal 312 13
3 = 312 22
0 contador 312 24
3 * 312 33
1 3 312 35
4 ; 312 36
5 if 314 9 3
0 temporal 314 12
3 > 314 21
1 200 314 23
4 { 314 27
5 continue 315 13 11
4 ; 315 21
4 } 316 9
4 } 317 5
5 let 320 5 1
0 resultado_complejo 320 9
3 = 320 28
0 calcular_complejo 320 30
4 ( 320 47
4 ) 320 48
4 ; 320 49
5 let 321 5 1
5 mut 321 9 2
0 acumulador 321 13
6 : 321 23
0 f64 321 25
3 = 321 29
1 0.0 321 31
4 ; 321 34
5 let 322 5 1
0 precision 322 9
6 : 322 18
0 f64 322 20
3 = 322 24
1 0.001 322 26
4 ; 322 31
5 for 325 5 8
0 iteracion 325 9
5 in 325 19 9
1 1 325 22
3 . 325 23
3 . 325 24
1 100 325 25
4 { 325 29
5 let 326 9 1
0 valor_actual 326 13
3 = 326 26
0 iteracion 326 28
3 * 326 38
0 pi 326 40
4 ; 326 42
0 acumulador 327 9
3 = 327 20
0 acumulador 327 22
3 + 327 33
0 valor_actual 327 35
4 ; 327 47
5 if 329 9 3
0 acumulador 329 12
3 > 329 23
1 1000.0 329 25
4 { 329 32
5 let 330 13 1
0 diferencia 330 17
3 = 330 28
0 acumulador 330 30
3 - 330 41
1 1000.0 330 43
4 ; 330 49
5 if 332 13 3
0 diferencia 332 16
3 < 332 27
0 precision 332 29
4 { 332 39
5 break 333 17 10
4 ; 333 22
4 } 334 13
4 } 335 9
4 } 336 5
4 } 337 1
5 fn 339 1 0
0 fibonacci 339 4
4 ( 339 13
0 n 339 14
6 : 339 15
0 i32 339 17
4 ) 339 20
3 - 339 22
3 > 339 23
0 i32 339 25
4 { 339 29
5 if 340 5 3
0 n 340 8
3 <= 340 10
1 1 340 13
4 { 340 15
5 return 341 9 12
0 n 341 16
4 ; 341 17
4 } 342 5
5 let 344 5 1
5 mut 344 9 2
0 a 344 13
6 : 344 14
0 i32 344 16
3 = 344 20
1 0 344 22
4 ; 344 23
5 let 345 5 1
5 mut 345 9 2
0 b 345 13
6 : 345 14
0 i32 345 16
3 = 345 20
1 1 345 22
4 ; 345 23
5 let 346 5 1
5 mut 346 9 2
0 temp 346 13
6 : 346 17
0 i32 346 19
3 = 346 23
1 0 346 25
4 ; 346 26
5 for 348 5 8
0 i 348 9
5 in 348 11 9
1 2 348 14
3 . 348 15
3 . 348 16
0 n 348 17
3 + 348 18
1 1 348 19
4 { 348 21
0 temp 349 9
3 = 349 14
0 a 349 16
3 + 349 18
0 b 349 20
4 ; 349 21
0 a 350 9
3 = 350 11
0 b 350 13
4 ; 350 14
0 b 351 9
3 = 351 11
0 temp 351 13
4 ; 351 17
4 } 352 5
5 return 354 5 12
0 b 354 12
4 ; 354 13
4 } 355 1
5 fn 357 1 0
0 factorial 357 4
4 ( 357 13
0 n 357 14
6 : 357 15
0 i32 357 17
4 ) 357 20
3 - 357 22
3 > 357 23
0 i32 357 25
4 { 357 29
5 if 358 5 3
0 n 358 8
3 <= 358 10
1 1 358 13
4 { 358 15
5 return 359 9 12
1 1 359 16
4 ; 359 17
4 } 360 5
5 let 362 5 1
5 mut 362 9 2
0 resultado 362 13
6 : 362 22
0 i32 362 24
3 = 362 28
1 1 362 30
4 ; 362 31
5 let 363 5 1
5 mut 363 9 2
0 i 363 13
6 : 363 14
0 i32 363 16
3 = 363 20
1 2 363 22
4 ; 363 23
5 while 365 5 6
0 i 365 11
3 <= 365 13
0 n 365 16
4 { 365 18
0 resultado 366 9
3 = 366 19
0 resultado 366 21
3 * 366 31
0 i 366 33
4 ; 366 34
0 i 367 9
3 = 367 11
0 i 367 13
3 + 367 15
1 1 367 17
4 ; 367 18
4 } 368 5
5 return 370 5 12
0 resultado 370 12
4 ; 370 21
4 } 371 1
5 fn 373 1 0
0 bubble_sort 373 4
4 ( 373 15
4 ) 373 16
3 - 373 18
3 > 373 19
0 i32 373 21
4 { 373 25
5 let 374 5 1
5 mut 374 9 2
0 arr 374 13
3 = 374 17
4 [ 374 19
1 64 374 20
4 , 374 22
1 34 374 24
4 , 374 26
1 25 374 28
4 , 374 30
1 12 374 32
4 , 374 34
1 22 374 36
4 , 374 38
1 11 374 40
4 , 374 42
1 90 374 44
4 ] 374 46
4 ; 374 47
5 let 375 5 1
0 n 375 9
6 : 375 10
0 i32 375 12
3 = 375 16
1 7 375 18
4 ; 375 19
5 for 377 5 8
0 i 377 9
5 in 377 11 9
1 0 377 14
3 . 377 15
3 . 377 16
0 n 377 17
3 - 377 18
1 1 377 19
4 { 377 21
5 for 378 9 8
0 j 378 13
5 in 378 15 9
1 0 378 18
3 . 378 19
3 . 378 20
0 n 378 21
3 - 378 22
0 i 378 23
3 - 378 24
1 1 378 25
4 { 378 27
5 if 379 13 3
0 arr 379 16
4 [ 379 19
0 j 379 20
4 ] 379 21
3 > 379 23
0 arr 379 25
4 [ 379 28
0 j 379 29
3 + 379 30
1 1 379 31
4 ] 379 32
4 { 379 34
5 let 380 17 1
0 temp 380 21
3 = 380 26
0 arr 380 28
4 [ 380 31
0 j 380 32
4 ] 380 33
4 ; 380 34
0 arr 381 17
4 [ 381 20
0 j 381 21
4 ] 381 22
3 = 381 24
0 arr 381 26
4 [ 381 29
0 j 381 30
3 + 381 31
1 1 381 32
4 ] 381 33
4 ; 381 34
0 arr 382 17
4 [ 382 20
0 j 382 21
3 + 382 22
1 1 382 23
4 ] 382 24
3 = 382 26
0 temp 382 28
4 ; 382 32
4 } 383 13
4 } 384 9
4 } 385 5
5 return 387 5 12
1 0 387 12
4 ; 387 13
4 } 388 1
5 fn 390 1 0
0 binary_search 390 4
4 ( 390 17
0 arr 390 18
6 : 390 21
0 i32 390 23
4 , 390 26
0 target 390 28
6 : 390 34
0 i32 390 36
4 ) 390 39
3 - 390 41
3 > 390 42
0 i32 390 44
4 { 390 48
5 let 391 5 1
5 mut 391 9 2
0 left 391 13
6 : 391 17
0 i32 391 19
3 = 391 23
1 0 391 25
4 ; 391 26
5 let 392 5 1
5 mut 392 9 2
0 right 392 13
6 : 392 18
0 i32 392 20
3 = 392 24
1 9 392 26
4 ; 392 27
5 while 394 5 6
0 left 394 11
3 <= 394 16
0 right 394 19
4 { 394 25
5 let 395 9 1
0 mid 395 13
3 = 395 17
0 left 395 19
3 + 395 24
4 ( 395 26
0 right 395 27
3 - 395 33
0 left 395 35
4 ) 395 39
3 / 395 41
1 2 395 43
4 ; 395 44
5 if 397 9 3
0 arr 397 12
3 == 397 16
0 target 397 19
4 { 397 26
5 return 398 13 12
0 mid 398 20
4 ; 398 23
4 } 399 9
5 fn 404 1 0
0 main 404 4
4 ( 404 8
4 ) 404 9
4 { 404 11
5 let 406 5 1
5 mut 406 9 2
0 contador 406 13
6 : 406 21
0 i32 406 23
3 = 406 27
1 0 406 29
4 ; 406 30
5 let 407 5 1
0 limite 407 9
6 : 407 15
0 i32 407 17
3 = 407 21
1 100 407 23
4 ; 407 26
5 let 408 5 1
0 pi 408 9
6 : 408 11
0 f64 408 13
3 = 408 17
1 3.14159 408 19
4 ; 408 26
5 let 409 5 1
0 nombre 409 9
6 : 409 15
0 str 409 17
3 = 409 21
2 "Analizador Léxico" 409 23
4 ; 409 43
5 let 410 5 1
0 activo 410 9
6 : 410 15
0 bool 410 17
3 = 410 22
5 true 410 24 13
4 ; 410 28
5 while 413 5 6
0 contador 413 11
3 < 413 20
0 limite 413 22
4 { 413 29
5 if 414 9 3
0 contador 414 12
3 % 414 21
1 2 414 23
3 == 414 25
1 0 414 28
4 { 414 30
0 contador 415 13
3 = 415 22
0 contador 415 24
3 + 415 33
1 1 415 35
4 ; 415 36
4 } 416 9
5 else 416 11 4
4 { 416 16
0 contador 417 13
3 = 417 22
0 contador 417 24
3 * 417 33
1 2 417 35
4 ; 417 36
4 } 418 9
5 let 421 9 1
0 resultado 421 13
3 = 421 23
0 contador 421 25
3 + 421 34
0 limite 421 36
3 * 421 43
1 2 421 45
4 ; 421 46
5 let 422 9 1
0 division 422 13
3 = 422 22
0 resultado 422 24
3 / 422 34
1 3 422 36
4 ; 422 37
5 let 423 9 1
0 modulo 423 13
3 = 423 20
0 division 423 22
3 % 423 31
1 7 423 33
4 ; 423 34
4 } 424 5
5 for 427 5 8
0 i 427 9
5 in 427 11 9
1 0 427 14
3 . 427 15
3 . 427 16
1 50 427 17
4 { 427 20
5 let 428 9 1
0 cuadrado 428 13
3 = 428 22
0 i 428 24
3 * 428 26
0 i 428 28
4 ; 428 29
5 let 429 9 1
0 cubo 429 13
3 = 429 18
0 cuadrado 429 20
3 * 429 29
0 i 429 31
4 ; 429 32
5 if 431 9 3
0 cubo 431 12
3 > 431 17
1 1000 431 19
4 { 431 24
5 break 432 13 10
4 ; 432 18
4 } 433 9
5 if 435 9 3
0 cuadrado 435 12
3 < 435 21
1 10 435 23
4 { 435 26
5 continue 436 13 11
4 ; 436 21
4 } 437 9
4 } 438 5
5 let 441 5 1
0 fib_resultado 441 9
3 = 441 23
0 fibonacci 441 25
4 ( 441 34
1 20 441 35
4 ) 441 37
4 ; 441 38
5 let 442 5 1
0 factorial_resultado 442 9
3 = 442 29
0 factorial 442 31
4 ( 442 40
1 10 442 41
4 ) 442 43
4 ; 442 44
5 let 443 5 1
0 array_ordenado 443 9
3 = 443 24
0 bubble_sort 443 26
4 ( 443 37
4 ) 443 38
4 ; 443 39
5 let 444 5 1
0 busqueda 444 9
3 = 444 18
0 binary_search 444 20
4 ( 444 33
0 array_ordenado 444 34
4 , 444 48
1 42 444 50
4 ) 444 52
4 ; 444 53
5 let 447 5 1
5 mut 447 9 2
0 suma 447 13
6 : 447 17
0 i32 447 19
3 = 447 23
1 0 447 25
4 ; 447 26
5 let 448 5 1
5 mut 448 9 2
0 producto 448 13
6 : 448 21
0 i32 448 23
3 = 448 27
1 1 448 29
4 ; 448 30
5 let 449 5 1
5 mut 449 9 2
0 promedio 449 13
6 : 449 21
0 f64 449 23
3 = 449 27
1 0.0 449 29
4 ; 449 32
5 let 452 5 1
0 numeros 452 9
3 = 452 17
4 [ 452 19
1 1 452 20
4 , 452 21
1 2 452 23
4 , 452 24
1 3 452 26
4 , 452 27
1 4 452 29
4 , 452 30
1 5 452 32
4 , 452 33
1 6 452 35
4 , 452 36
1 7 452 38
4 , 452 39
1 8 452 41
4 , 452 42
1 9 452 44
4 , 452 45
1 10 452 47
4 ] 452 49
4 ; 452 50
5 let 453 5 1
5 mut 453 9 2
0 indice 453 13
6 : 453 19
0 i32 453 21
3 = 453 25
1 0 453 27
4 ; 453 28
5 while 455 5 6
0 indice 455 11
3 < 455 18
1 10 455 20
4 { 455 23
0 suma 456 9
3 = 456 14
0 suma 456 16
3 + 456 21
0 numeros 456 23
4 [ 456 30
0 indice 456 31
4 ] 456 37
4 ; 456 38
0 producto 457 9
3 = 457 18
0 producto 457 20
3 * 457 29
0 numeros 457 31
4 [ 457 38
0 indice 457 39
4 ] 457 45
4 ; 457 46
0 indice 458 9
3 = 458 16
0 indice 458 18
3 + 458 25
1 1 458 27
4 ; 458 28
4 } 459 5
0 promedio 461 5
3 = 461 14
0 suma 461 16
3 / 461 21
1 10.0 461 23
4 ; 461 27
5 for 464 5 8
0 x 464 9
5 in 464 11 9
1 1 464 14
3 . 464 15
3 . 464 16
1 20 464 17
4 { 464 20
5 for 465 9 8
0 y 465 13
5 in 465 15 9
1 1 465 18
3 . 465 19
3 . 465 20
1 20 465 21
4 { 465 24
5 let 466 13 1
0 multiplicacion 466 17
3 = 466 32
0 x 466 34
3 * 466 36
0 y 466 38
4 ; 466 39
5 if 468 13 3
0 multiplicacion 468 16
3 % 468 31
1 3 468 33
3 == 468 35
1 0 468 38
4 { 468 40
5 if 469 17 3
0 multiplicacion 469 20
3 % 469 35
1 5 469 37
3 == 469 39
1 0 469 42
4 { 469 44
5 let 470 21 1
0 especial 470 25
3 = 470 34
0 multiplicacion 470 36
3 / 470 51
1 15 470 53
4 ; 470 55
4 } 471 17
5 else 471 19 4
4 { 471 24
5 let 472 21 1
0 normal 472 25
3 = 472 32
0 multiplicacion 472 34
3 / 472 49
1 3 472 51
4 ; 472 52
4 } 473 17
4 } 474 13
4 } 475 9
4 } 476 5
5 let 479 5 1
5 mut 479 9 2
0 matriz 479 13
6 : 479 19
0 i32 479 21
3 = 479 25
1 0 479 27
4 ; 479 28
5 let 480 5 1
0 filas 480 9
6 : 480 14
0 i32 480 16
3 = 480 20
1 5 480 22
4 ; 480 23
5 let 481 5 1
0 columnas 481 9
6 : 481 17
0 i32 481 19
3 = 481 23
1 5 481 25
4 ; 481 26
5 for 483 5 8
0 i 483 9
5 in 483 11 9
1 0 483 14
3 . 483 15
3 . 483 16
0 filas 483 17
4 { 483 23
5 for 484 9 8
0 j 484 13
5 in 484 15 9
1 0 484 18
3 . 484 19
3 . 484 20
0 columnas 484 21
4 { 484 30
0 matriz 485 13
3 = 485 20
0 i 485 22
3 * 485 24
0 columnas 485 26
3 + 485 35
0 j 485 37
4 ; 485 38
5 let 486 13 1
0 valor 486 17
3 = 486 23
0 matriz 486 25
3 * 486 32
1 2 486 34
3 + 486 36
1 1 486 38
4 ; 486 39
4 } 487 9
4 } 488 5
5 let 491 5 1
0 cadena1 491 9
6 : 491 16
0 str 491 18
3 = 491 22
2 "Hola" 491 24
4 ; 491 30
5 let 492 5 1
0 cadena2 492 9
6 : 492 16
0 str 492 18
3 = 492 22
2 "Mundo" 492 24
4 ; 492 31
5 let 493 5 1
0 longitud1 493 9
3 = 493 19
0 len 493 21
4 ( 493 24
0 cadena1 493 25
4 ) 493 32
4 ; 493 33
5 let 494 5 1
0 longitud2 494 9
3 = 494 19
0 len 494 21
4 ( 494 24
0 cadena2 494 25
4 ) 494 32
4 ; 494 33
5 match 497 5 5
0 contador 497 11
4 { 497 20
1 0 498 9
3 = 498 11
3 > 498 12
5 let 498 14 1
0 cero 498 18
3 = 498 23
5 true 498 25 13
4 , 498 29
1 1 499 9
3 = 499 11
3 > 499 12
5 let 499 14 1
0 uno 499 18
3 = 499 22
5 true 499 24 13
4 , 499 28
1 2 500 9
3 = 500 11
3 > 500 12
0 l 500 14
6 # 500 15
0 et 500 16
0 dos 500 19
3 = 500 23
5 true 500 25 13
4 , 500 29
0 _ 501 9
3 = 501 11
3 > 501 12
5 let 501 14 1
0 otro 501 18
3 = 501 23
5 true 501 25 13
4 , 501 29
4 } 502 5
5 loop 505 5 7
4 { 505 10
6 @ 506 9
0 contador 506 10
3 = 506 19
0 contador 506 21
3 - 506 30
1 1 506 32
4 ; 506 33
6 # 506 34
5 if 508 9 3
0 contador 508 12
3 <= 508 21
1 0 508 24
4 { 508 26
5 break 509 13 10
4 ; 509 18
4 } 510 9
5 let 512 9 1
0 temporal 512 13
3 = 512 22
0 contador 512 24
3 * 512 33
1 3 512 35
4 ; 512 36
5 if 514 9 3
0 temporal 514 12
3 > 514 21
1 200 514 23
4 { 514 27
5 continue 515 13 11
4 ; 515 21
4 } 516 9
4 } 517 5
5 let 520 5 1
0 resultado_complejo 520 9
3 = 520 28
0 calcular_complejo 520 30
4 ( 520 47
4 ) 520 48
4 ; 520 49
5 let 521 5 1
5 mut 521 9 2
0 acumulador 521 13
6 : 521 23
0 f64 521 25
3 = 521 29
1 0.0 521 31
4 ; 521 34
5 let 522 5 1
0 precision 522 9
6 : 522 18
0 f64 522 20
3 = 522 24
1 0.001 522 26
4 ; 522 31
5 for 525 5 8
0 iteracion 525 9
5 in 525 19 9
1 1 525 22
3 . 525 23
3 . 525 24
1 100 525 25
4 { 525 29
5 let 526 9 1
0 valor_actual 526 13
3 = 526 26
0 iteracion 526 28
3 * 526 38
0 pi 526 40
4 ; 526 42
0 acumulador 527 9
3 = 527 20
0 acumulador 527 22
3 + 527 33
0 valor_actual 527 35
4 ; 527 47
5 if 529 9 3
0 acumulador 529 12
3 > 529 23
1 1000.0 529 25
4 { 529 32
5 let 530 13 1
0 diferencia 530 17
3 = 530 28
0 acumulador 530 30
3 - 530 41
1 1000.0 530 43
4 ; 530 49
5 if 532 13 3
0 diferencia 532 16
3 < 532 27
0 precision 532 29
4 { 532 39
5 break 533 17 10
4 ; 533 22
4 } 534 13
4 } 535 9
4 } 536 5
4 } 537 1
5 fn 539 1 0
0 fibonacci 539 4
4 ( 539 13
0 n 539 14
6 : 539 15
0 i32 539 17
4 ) 539 20
3 - 539 22
3 > 539 23
0 i32 539 25
4 { 539 29
5 if 540 5 3
0 n 540 8
3 <= 540 10
1 1 540 13
4 { 540 15
5 return 541 9 12
0 n 541 16
4 ; 541 17
4 } 542 5
5 let 544 5 1
5 mut 544 9 2
0 a 544 13
6 : 544 14
0 i32 544 16
3 = 544 20
1 0 544 22
4 ; 544 23
5 let 545 5 1
5 mut 545 9 2
0 b 545 13
6 : 545 14
0 i32 545 16
3 = 545 20
1 1 545 22
4 ; 545 23
5 let 546 5 1
5 mut 546 9 2
0 temp 546 13
6 : 546 17
0 i32 546 19
3 = 546 23
1 0 546 25
4 ; 546 26
5 for 548 5 8
0 i 548 9
5 in 548 11 9
1 2 548 14
3 . 548 15
3 . 548 16
0 n 548 17
3 + 548 18
1 1 548 19
4 { 548 21
0 temp 549 9
3 = 549 14
0 a 549 16
3 + 549 18
0 b 549 20
4 ; 549 21
0 a 550 9
3 = 550 11
0 b 550 13
4 ; 550 14
0 b 551 9
3 = 551 11
0 temp 551 13
4 ; 551 17
4 } 552 5
5 return 554 5 12
0 b 554 12
4 ; 554 13
4 } 555 1
5 fn 557 1 0
0 factorial 557 4
4 ( 557 13
0 n 557 14
6 : 557 15
0 i32 557 17
4 ) 557 20
3 - 557 22
3 > 557 23
0 i32 557 25
4 { 557 29
5 if 558 5 3
0 n 558 8
3 <= 558 10
1 1 558 13
4 { 558 15
5 return 559 9 12
1 1 559 16
4 ; 559 17
4 } 560 5
5 let 562 5 1
5 mut 562 9 2
0 resultado 562 13
6 : 562 22
0 i32 562 24
3 = 562 28
1 1 562 30
4 ; 562 31
5 let 563 5 1
5 mut 563 9 2
0 i 563 13
6 : 563 14
0 i32 563 16
3 = 563 20
1 2 563 22
4 ; 563 23
5 while 565 5 6
0 i 565 11
3 <= 565 13
0 n 565 16
4 { 565 18
0 resultado 566 9
3 = 566 19
0 resultado 566 21
3 * 566 31
0 i 566 33
4 ; 566 34
0 i 567 9
3 = 567 11
0 i 567 13
3 + 567 15
1 1 567 17
4 ; 567 18
4 } 568 5
5 return 570 5 12
0 resultado 570 12
4 ; 570 21
4 } 571 1
5 fn 573 1 0
0 bubble_sort 573 4
4 ( 573 15
4 ) 573 16
3 - 573 18
3 > 573 19
0 i32 573 21
4 { 573 25
5 let 574 5 1
5 mut 574 9 2
0 arr 574 13
3 = 574 17
4 [ 574 19
1 64 574 20
4 , 574 22
1 34 574 24
4 , 574 26
1 25 574 28
4 , 574 30
1 12 574 32
4 , 574 34
1 22 574 36
4 , 574 38
1 11 574 40
4 , 574 42
1 90 574 44
4 ] 574 46
4 ; 574 47
5 let 575 5 1
0 n 575 9
6 : 575 10
0 i32 575 12
3 = 575 16
1 7 575 18
4 ; 575 19
5 for 577 5 8
0 i 577 9
5 in 577 11 9
1 0 577 14
3 . 577 15
3 . 577 16
0 n 577 17
3 - 577 18
1 1 577 19
4 { 577 21
5 for 578 9 8
0 j 578 13
5 in 578 15 9
1 0 578 18
3 . 578 19
3 . 578 20
0 n 578 21
3 - 578 22
0 i 578 23
3 - 578 24
1 1 578 25
4 { 578 27
5 if 579 13 3
0 arr 579 16
4 [ 579 19
0 j 579 20
4 ] 579 21
3 > 579 23
0 arr 579 25
4 [ 579 28
0 j 579 29
3 + 579 30
1 1 579 31
4 ] 579 32
4 { 579 34
5 let 580 17 1
0 temp 580 21
3 = 580 26
0 arr 580 28
4 [ 580 31
0 j 580 32
4 ] 580 33
4 ; 580 34
0 arr 581 17
4 [ 581 20
0 j 581 21
4 ] 581 22
3 = 581 24
0 arr 581 26
4 [ 581 29
0 j 581 30
3 + 581 31
1 1 581 32
4 ] 581 33
4 ; 581 34
0 arr 582 17
4 [ 582 20
0 j 582 21
3 + 582 22
1 1 582 23
4 ] 582 24
3 = 582 26
0 temp 582 28
4 ; 582 32
4 } 583 13
4 } 584 9
4 } 585 5
5 return 587 5 12
1 0 587 12
4 ; 587 13
4 } 588 1
5 fn 590 1 0
0 binary_search 590 4
4 ( 590 17
0 arr 590 18
6 : 590 21
0 i32 590 23
4 , 590 26
0 target 590 28
6 : 590 34
0 i32 590 36
4 ) 590 39
3 - 590 41
3 > 590 42
0 i32 590 44
4 { 590 48
5 let 591 5 1
5 mut 591 9 2
0 left 591 13
6 : 591 17
0 i32 591 19
3 = 591 23
1 0 591 25
4 ; 591 26
5 let 592 5 1
5 mut 592 9 2
0 right 592 13
6 : 592 18
0 i32 592 20
3 = 592 24
1 9 592 26
4 ; 592 27
5 while 594 5 6
0 left 594 11
3 <= 594 16
0 right 594 19
4 { 594 25
5 let 595 9 1
0 mid 595 13
3 = 595 17
0 left 595 19
3 + 595 24
4 ( 595 26
0 right 595 27
3 - 595 33
0 left 595 35
4 ) 595 39
3 / 595 41
1 2 595 43
4 ; 595 44
5 if 597 9 3
0 arr 597 12
3 == 597 16
0 target 597 19
4 { 597 26
5 return 598 13 12
0 mid 598 20
4 ; 598 23
4 } 599 9
5 fn 604 1 0
0 main 604 4
4 ( 604 8
4 ) 604 9
4 { 604 11
5 let 606 5 1
5 mut 606 9 2
0 contador 606 13
6 : 606 21
0 i32 606 23
3 = 606 27
1 0 606 29
4 ; 606 30
5 let 607 5 1
0 limite 607 9
6 : 607 15
0 i32 607 17
3 = 607 21
1 100 607 23
4 ; 607 26
5 let 608 5 1
0 pi 608 9
6 : 608 11
0 f64 608 13
3 = 608 17
1 3.14159 608 19
4 ; 608 26
5 let 609 5 1
0 nombre 609 9
6 : 609 15
0 str 609 17
3 = 609 21
2 "Analizador Léxico" 609 23
4 ; 609 43
5 let 610 5 1
0 activo 610 9
6 : 610 15
0 bool 610 17
3 = 610 22
5 true 610 24 13
4 ; 610 28
5 while 613 5 6
0 contador 613 11
3 < 613 20
0 limite 613 22
4 { 613 29
5 if 614 9 3
0 contador 614 12
3 % 614 21
1 2 614 23
3 == 614 25
1 0 614 28
4 { 614 30
0 contador 615 13
3 = 615 22
0 contador 615 24
3 + 615 33
1 1 615 35
4 ; 615 36
4 } 616 9
5 else 616 11 4
4 { 616 16
0 contador 617 13
3 = 617 22
0 contador 617 24
3 * 617 33
1 2 617 35
4 ; 617 36
4 } 618 9
5 let 621 9 1
0 resultado 621 13
3 = 621 23
0 contador 621 25
3 + 621 34
0 limite 621 36
3 * 621 43
1 2 621 45
4 ; 621 46
5 let 622 9 1
0 division 622 13
3 = 622 22
0 resultado 622 24
3 / 622 34
1 3 622 36
4 ; 622 37
5 let 623 9 1
0 modulo 623 13
3 = 623 20
0 division 623 22
3 % 623 31
1 7 623 33
4 ; 623 34
4 } 624 5
5 for 627 5 8
0 i 627 9
5 in 627 11 9
1 0 627 14
3 . 627 15
3 . 627 16
1 50 627 17
4 { 627 20
5 let 628 9 1
0 cuadrado 628 13
3 = 628 22
0 i 628 24
3 * 628 26
0 i 628 28
4 ; 628 29
5 let 629 9 1
0 cubo 629 13
3 = 629 18
0 cuadrado 629 20
3 * 629 29
0 i 629 31
4 ; 629 32
5 if 631 9 3
0 cubo 631 12
3 > 631 17
1 1000 631 19
4 { 631 24
5 break 632 13 10
4 ; 632 18
4 } 633 9
5 if 635 9 3
0 cuadrado 635 12
3 < 635 21
1 10 635 23
4 { 635 26
5 continue 636 13 11
4 ; 636 21
4 } 637 9
4 } 638 5
5 let 641 5 1
0 fib_resultado 641 9
3 = 641 23
0 fibonacci 641 25
4 ( 641 34
1 20 641 35
4 ) 641 37
4 ; 641 38
5 let 642 5 1
0 factorial_resultado 642 9
3 = 642 29
0 factorial 642 31
4 ( 642 40
1 10 642 41
4 ) 642 43
4 ; 642 44
5 let 643 5 1
0 array_ordenado 643 9
3 = 643 24
0 bubble_sort 643 26
4 ( 643 37
4 ) 643 38
4 ; 643 39
5 let 644 5 1
0 busqueda 644 9
3 = 644 18
0 binary_search 644 20
4 ( 644 33
0 array_ordenado 644 34
4 , 644 48
1 42 644 50
4 ) 644 52
4 ; 644 53
5 let 647 5 1
5 mut 647 9 2
0 suma 647 13
6 : 647 17
0 i32 647 19
3 = 647 23
1 0 647 25
4 ; 647 26
5 let 648 5 1
5 mut 648 9 2
0 producto 648 13
6 : 648 21
0 i32 648 23
3 = 648 27
1 1 648 29
4 ; 648 30
5 let 649 5 1
5 mut 649 9 2
0 promedio 649 13
6 : 649 21
0 f64 649 23
3 = 649 27
1 0.0 649 29
4 ; 649 32
5 let 652 5 1
0 numeros 652 9
3 = 652 17
4 [ 652 19
1 1 652 20
4 , 652 21
1 2 652 23
4 , 652 24
1 3 652 26
4 , 652 27
1 4 652 29
4 , 652 30
1 5 652 32
4 , 652 33
1 6 652 35
4 , 652 36
1 7 652 38
4 , 652 39
1 8 652 41
4 , 652 42
1 9 652 44
4 , 652 45
1 10 652 47
4 ] 652 49
4 ; 652 50
5 let 653 5 1
5 mut 653 9 2
0 indice 653 13
6 : 653 19
0 i32 653 21
3 = 653 25
1 0 653 27
4 ; 653 28
5 while 655 5 6
0 indice 655 11
3 < 655 18
1 10 655 20
4 { 655 23
0 suma 656 9
3 = 656 14
0 suma 656 16
3 + 656 21
0 numeros 656 23
4 [ 656 30
0 indice 656 31
4 ] 656 37
4 ; 656 38
0 producto 657 9
3 = 657 18
0 producto 657 20
3 * 657 29
0 numeros 657 31
4 [ 657 38
0 indice 657 39
4 ] 657 45
4 ; 657 46
0 indice 658 9
3 = 658 16
0 indice 658 18
3 + 658 25
1 1 658 27
4 ; 658 28
4 } 659 5
0 promedio 661 5
3 = 661 14
0 suma 661 16
3 / 661 21
1 10.0 661 23
4 ; 661 27
5 for 664 5 8
0 x 664 9
5 in 664 11 9
1 1 664 14
3 . 664 15
3 . 664 16
1 20 664 17
4 { 664 20
5 for 665 9 8
0 y 665 13
5 in 665 15 9
1 1 665 18
3 . 665 19
3 . 665 20
1 20 665 21
4 { 665 24
5 let 666 13 1
0 multiplicacion 666 17
3 = 666 32
0 x 666 34
3 * 666 36
0 y 666 38
4 ; 666 39
5 if 668 13 3
0 multiplicacion 668 16
3 % 668 31
1 3 668 33
3 == 668 35
1 0 668 38
4 { 668 40
5 if 669 17 3
0 multiplicacion 669 20
3 % 669 35
1 5 669 37
3 == 669 39
1 0 669 42
4 { 669 44
5 let 670 21 1
0 especial 670 25
3 = 670 34
0 multiplicacion 670 36
3 / 670 51
1 15 670 53
4 ; 670 55
4 } 671 17
5 else 671 19 4
4 { 671 24
5 let 672 21 1
0 normal 672 25
3 = 672 32
0 multiplicacion 672 34
3 / 672 49
1 3 672 51
4 ; 672 52
4 } 673 17
4 } 674 13
4 } 675 9
4 } 676 5
5 let 679 5 1
5 mut 679 9 2
0 matriz 679 13
6 : 679 19
0 i32 679 21
3 = 679 25
1 0 679 27
4 ; 679 28
5 let 680 5 1
0 filas 680 9
6 : 680 14
0 i32 680 16
3 = 680 20
1 5 680 22
4 ; 680 23
5 let 681 5 1
0 columnas 681 9
6 : 681 17
0 i32 681 19
3 = 681 23
1 5 681 25
4 ; 681 26
5 for 683 5 8
0 i 683 9
5 in 683 11 9
1 0 683 14
3 . 683 15
3 . 683 16
0 filas 683 17
4 { 683 23
5 for 684 9 8
0 j 684 13
5 in 684 15 9
1 0 684 18
3 . 684 19
3 . 684 20
0 columnas 684 21
4 { 684 30
0 matriz 685 13
3 = 685 20
0 i 685 22
3 * 685 24
0 columnas 685 26
3 + 685 35
0 j 685 37
4 ; 685 38
5 let 686 13 1
0 valor 686 17
3 = 686 23
0 matriz 686 25
3 * 686 32
1 2 686 34
3 + 686 36
1 1 686 38
4 ; 686 39
4 } 687 9
4 } 688 5
5 let 691 5 1
0 cadena1 691 9
6 : 691 16
0 str 691 18
3 = 691 22
2 "Hola" 691 24
4 ; 691 30
5 let 692 5 1
0 cadena2 692 9
6 : 692 16
0 str 692 18
3 = 692 22
2 "Mundo" 692 24
4 ; 692 31
5 let 693 5 1
0 longitud1 693 9
3 = 693 19
0 len 693 21
4 ( 693 24
0 cadena1 693 25
4 ) 693 32
4 ; 693 33
5 let 694 5 1
0 longitud2 694 9
3 = 694 19
0 len 694 21
4 ( 694 24
0 cadena2 694 25
4 ) 694 32
4 ; 694 33
5 match 697 5 5
0 contador 697 11
4 { 697 20
1 0 698 9
3 = 698 11
3 > 698 12
5 let 698 14 1
0 cero 698 18
3 = 698 23
5 true 698 25 13
4 , 698 29
1 1 699 9
3 = 699 11
3 > 699 12
5 let 699 14 1
0 uno 699 18
3 = 699 22
5 true 699 24 13
4 , 699 28
1 2 700 9
3 = 700 11
3 > 700 12
5 let 700 14 1
0 dos 700 18
3 = 700 22
5 true 700 24 13
4 , 700 28
0 _ 701 9
3 = 701 11
3 > 701 12
5 let 701 14 1
0 otro 701 18
3 = 701 23
5 true 701 25 13
4 , 701 29
4 } 702 5
5 loop 705 5 7
4 { 705 10
0 contador 706 9
3 = 706 18
0 contador 706 20
3 - 706 29
1 1 706 31
4 ; 706 32
5 if 708 9 3
0 contador 708 12
3 <= 708 21
1 0 708 24
4 { 708 26
5 break 709 13 10
4 ; 709 18
4 } 710 9
5 let 712 9 1
0 temporal 712 13
3 = 712 22
0 contador 712 24
3 * 712 33
1 3 712 35
4 ; 712 36
5 if 714 9 3
0 temporal 714 12
3 > 714 21
1 200 714 23
4 { 714 27
5 continue 715 13 11
4 ; 715 21
4 } 716 9
4 } 717 5
5 let 720 5 1
0 resultado_complejo 720 9
3 = 720 28
0 calcular_complejo 720 30
4 ( 720 47
4 ) 720 48
4 ; 720 49
5 let 721 5 1
5 mut 721 9 2
0 acumulador 721 13
6 : 721 23
0 f64 721 25
3 = 721 29
1 0.0 721 31
4 ; 721 34
5 let 722 5 1
0 precision 722 9
6 : 722 18
0 f64 722 20
3 = 722 24
1 0.001 722 26
4 ; 722 31
5 for 725 5 8
0 iteracion 725 9
5 in 725 19 9
1 1 725 22
3 . 725 23
3 . 725 24
1 100 725 25
4 { 725 29
5 let 726 9 1
0 valor_actual 726 13
3 = 726 26
0 iteracion 726 28
3 * 726 38
0 pi 726 40
4 ; 726 42
0 acumulador 727 9
3 = 727 20
0 acumulador 727 22
3 + 727 33
0 valor_actual 727 35
4 ; 727 47
5 if 729 9 3
0 acumulador 729 12
3 > 729 23
1 1000.0 729 25
4 { 729 32
5 let 730 13 1
0 diferencia 730 17
3 = 730 28
0 acumulador 730 30
3 - 730 41
1 1000.0 730 43
4 ; 730 49
5 if 732 13 3
0 diferencia 732 16
3 < 732 27
0 precision 732 29
4 { 732 39
5 break 733 17 10
4 ; 733 22
4 } 734 13
4 } 735 9
4 } 736 5
4 } 737 1
5 fn 739 1 0
0 fibonacci 739 4
4 ( 739 13
0 n 739 14
6 : 739 15
0 i32 739 17
4 ) 739 20
3 - 739 22
3 > 739 23
0 i32 739 25
4 { 739 29
5 if 740 5 3
0 n 740 8
3 <= 740 10
1 1 740 13
4 { 740 15
5 return 741 9 12
0 n 741 16
4 ; 741 17
4 } 742 5
5 let 744 5 1
5 mut 744 9 2
0 a 744 13
6 : 744 14
0 i32 744 16
3 = 744 20
1 0 744 22
4 ; 744 23
5 let 745 5 1
5 mut 745 9 2
0 b 745 13
6 : 745 14
0 i32 745 16
3 = 745 20
1 1 745 22
4 ; 745 23
5 let 746 5 1
5 mut 746 9 2
0 temp 746 13
6 : 746 17
0 i32 746 19
3 = 746 23
1 0 746 25
4 ; 746 26
5 for 748 5 8
0 i 748 9
5 in 748 11 9
1 2 748 14
3 . 748 15
3 . 748 16
0 n 748 17
3 + 748 18
1 1 748 19
4 { 748 21
0 temp 749 9
3 = 749 14
0 a 749 16
3 + 749 18
0 b 749 20
4 ; 749 21
0 a 750 9
3 = 750 11
0 b 750 13
4 ; 750 14
0 b 751 9
3 = 751 11
0 temp 751 13
4 ; 751 17
4 } 752 5
5 return 754 5 12
0 b 754 12
4 ; 754 13
4 } 755 1
5 fn 757 1 0
0 factorial 757 4
4 ( 757 13
0 n 757 14
6 : 757 15
0 i32 757 17
4 ) 757 20
3 - 757 22
3 > 757 23
0 i32 757 25
4 { 757 29
5 if 758 5 3
0 n 758 8
3 <= 758 10
1 1 758 13
4 { 758 15
5 return 759 9 12
1 1 759 16
4 ; 759 17
4 } 760 5
5 let 762 5 1
5 mut 762 9 2
0 resultado 762 13
6 : 762 22
0 i32 762 24
3 = 762 28
1 1 762 30
4 ; 762 31
5 let 763 5 1
5 mut 763 9 2
0 i 763 13
6 : 763 14
0 i32 763 16
3 = 763 20
1 2 763 22
4 ; 763 23
5 while 765 5 6
0 i 765 11
3 <= 765 13
0 n 765 16
4 { 765 18
0 resultado 766 9
3 = 766 19
0 resultado 766 21
3 * 766 31
0 i 766 33
4 ; 766 34
0 i 767 9
3 = 767 11
0 i 767 13
3 + 767 15
1 1 767 17
4 ; 767 18
4 } 768 5
5 return 770 5 12
0 resultado 770 12
4 ; 770 21
4 } 771 1
5 fn 773 1 0
0 bubble_sort 773 4
4 ( 773 15
4 ) 773 16
3 - 773 18
3 > 773 19
0 i32 773 21
4 { 773 25
5 let 774 5 1
5 mut 774 9 2
0 arr 774 13
3 = 774 17
4 [ 774 19
1 64 774 20
4 , 774 22
1 34 774 24
4 , 774 26
1 25 774 28
4 , 774 30
1 12 774 32
4 , 774 34
1 22 774 36
4 , 774 38
1 11 774 40
4 , 774 42
1 90 774 44
4 ] 774 46
4 ; 774 47
5 let 775 5 1
0 n 775 9
6 : 775 10
0 i32 775 12
3 = 775 16
1 7 775 18
4 ; 775 19
5 for 777 5 8
0 i 777 9
5 in 777 11 9
1 0 777 14
3 . 777 15
3 . 777 16
0 n 777 17
3 - 777 18
1 1 777 19
4 { 777 21
5 for 778 9 8
0 j 778 13
5 in 778 15 9
1 0 778 18
3 . 778 19
3 . 778 20
0 n 778 21
3 - 778 22
0 i 778 23
3 - 778 24
1 1 778 25
4 { 778 27
5 if 779 13 3
0 arr 779 16
4 [ 779 19
0 j 779 20
4 ] 779 21
3 > 779 23
0 arr 779 25
4 [ 779 28
0 j 779 29
3 + 779 30
1 1 779 31
4 ] 779 32
4 { 779 34
5 let 780 17 1
0 temp 780 21
3 = 780 26
0 arr 780 28
4 [ 780 31
0 j 780 32
4 ] 780 33
4 ; 780 34
0 arr 781 17
4 [ 781 20
0 j 781 21
4 ] 781 22
3 = 781 24
0 arr 781 26
4 [ 781 29
0 j 781 30
3 + 781 31
1 1 781 32
4 ] 781 33
4 ; 781 34
0 arr 782 17
4 [ 782 20
0 j 782 21
3 + 782 22
1 1 782 23
4 ] 782 24
3 = 782 26
0 temp 782 28
4 ; 782 32
4 } 783 13
4 } 784 9
4 } 785 5
5 return 787 5 12
1 0 787 12
4 ; 787 13
4 } 788 1
5 fn 790 1 0
0 binary_search 790 4
4 ( 790 17
0 arr 790 18
6 : 790 21
0 i32 790 23
4 , 790 26
0 target 790 28
6 : 790 34
0 i32 790 36
4 ) 790 39
3 - 790 41
3 > 790 42
0 i32 790 44
4 { 790 48
5 let 791 5 1
5 mut 791 9 2
0 left 791 13
6 : 791 17
0 i32 791 19
3 = 791 23
1 0 791 25
4 ; 791 26
5 let 792 5 1
5 mut 792 9 2
0 right 792 13
6 : 792 18
0 i32 792 20
3 = 792 24
1 9 792 26
4 ; 792 27
5 while 794 5 6
0 left 794 11
3 <= 794 16
0 right 794 19
4 { 794 25
5 let 795 9 1
0 mid 795 13
3 = 795 17
0 left 795 19
3 + 795 24
4 ( 795 26
0 right 795 27
3 - 795 33
0 left 795 35
4 ) 795 39
3 / 795 41
1 2 795 43
4 ; 795 44
5 if 797 9 3
0 arr 797 12
3 == 797 16
0 target 797 19
4 { 797 26
5 return 798 13 12
0 mid 798 20
4 ; 798 23
4 } 799 9
5 fn 804 1 0
0 main 804 4
4 ( 804 8
4 ) 804 9
4 { 804 11
5 let 806 5 1
5 mut 806 9 2
0 contador 806 13
6 : 806 21
0 i32 806 23
3 = 806 27
1 0 806 29
4 ; 806 30
5 let 807 5 1
0 limite 807 9
6 : 807 15
0 i32 807 17
3 = 807 21
1 100 807 23
4 ; 807 26
5 let 808 5 1
0 pi 808 9
6 : 808 11
0 f64 808 13
3 = 808 17
1 3.14159 808 19
4 ; 808 26
5 let 809 5 1
0 nombre 809 9
6 : 809 15
0 str 809 17
3 = 809 21
2 "Analizador Léxico" 809 23
4 ; 809 43
5 let 810 5 1
0 activo 810 9
6 : 810 15
0 bool 810 17
3 = 810 22
5 true 810 24 13
4 ; 810 28
5 while 813 5 6
0 contador 813 11
3 < 813 20
0 limite 813 22
4 { 813 29
5 if 814 9 3
0 contador 814 12
3 % 814 21
1 2 814 23
3 == 814 25
1 0 814 28
4 { 814 30
0 contador 815 13
3 = 815 22
0 contador 815 24
3 + 815 33
1 1 815 35
4 ; 815 36
4 } 816 9
5 else 816 11 4
4 { 816 16
0 contador 817 13
3 = 817 22
0 contador 817 24
3 * 817 33
1 2 817 35
4 ; 817 36
4 } 818 9
5 let 821 9 1
0 resultado 821 13
3 = 821 23
0 contador 821 25
3 + 821 34
0 limite 821 36
3 * 821 43
1 2 821 45
4 ; 821 46
5 let 822 9 1
0 division 822 13
3 = 822 22
0 resultado 822 24
3 / 822 34
1 3 822 36
4 ; 822 37
5 let 823 9 1
0 modulo 823 13
3 = 823 20
0 division 823 22
3 % 823 31
1 7 823 33
4 ; 823 34
4 } 824 5
5 for 827 5 8
0 i 827 9
5 in 827 11 9
1 0 827 14
3 . 827 15
3 . 827 16
1 50 827 17
4 { 827 20
5 let 828 9 1
0 cuadrado 828 13
3 = 828 22
0 i 828 24
3 * 828 26
0 i 828 28
4 ; 828 29
5 let 829 9 1
0 cubo 829 13
3 = 829 18
0 cuadrado 829 20
3 * 829 29
0 i 829 31
4 ; 829 32
5 if 831 9 3
0 cubo 831 12
3 > 831 17
1 1000 831 19
4 { 831 24
5 break 832 13 10
4 ; 832 18
4 } 833 9
5 if 835 9 3
0 cuadrado 835 12
3 < 835 21
1 10 835 23
4 { 835 26
5 continue 836 13 11
4 ; 836 21
4 } 837 9
4 } 838 5
5 let 841 5 1
0 fib_resultado 841 9
3 = 841 23
0 fibonacci 841 25
4 ( 841 34
1 20 841 35
4 ) 841 37
4 ; 841 38
5 let 842 5 1
0 factorial_resultado 842 9
3 = 842 29
0 factorial 842 31
4 ( 842 40
1 10 842 41
4 ) 842 43
4 ; 842 44
5 let 843 5 1
0 array_ordenado 843 9
3 = 843 24
0 bubble_sort 843 26
4 ( 843 37
4 ) 843 38
4 ; 843 39
5 let 844 5 1
0 busqueda 844 9
3 = 844 18
0 binary_search 844 20
4 ( 844 33
0 array_ordenado 844 34
4 , 844 48
1 42 844 50
4 ) 844 52
4 ; 844 53
5 let 847 5 1
5 mut 847 9 2
0 suma 847 13
6 : 847 17
0 i32 847 19
3 = 847 23
1 0 847 25
4 ; 847 26
5 let 848 5 1
5 mut 848 9 2
0 producto 848 13
6 : 848 21
0 i32 848 23
3 = 848 27
1 1 848 29
4 ; 848 30
5 let 849 5 1
5 mut 849 9 2
0 promedio 849 13
6 : 849 21
0 f64 849 23
3 = 849 27
1 0.0 849 29
4 ; 849 32
5 let 852 5 1
0 numeros 852 9
3 = 852 17
4 [ 852 19
1 1 852 20
4 , 852 21
1 2 852 23
4 , 852 24
1 3 852 26
4 , 852 27
1 4 852 29
4 , 852 30
1 5 852 32
4 , 852 33
1 6 852 35
4 , 852 36
1 7 852 38
4 , 852 39
1 8 852 41
4 , 852 42
1 9 852 44
4 , 852 45
1 10 852 47
4 ] 852 49
4 ; 852 50
5 let 853 5 1
5 mut 853 9 2
0 indice 853 13
6 : 853 19
0 i32 853 21
3 = 853 25
1 0 853 27
4 ; 853 28
5 while 855 5 6
0 indice 855 11
3 < 855 18
1 10 855 20
4 { 855 23
0 suma 856 9
3 = 856 14
0 suma 856 16
3 + 856 21
0 numeros 856 23
4 [ 856 30
0 indice 856 31
4 ] 856 37
4 ; 856 38
0 producto 857 9
3 = 857 18
0 producto 857 20
3 * 857 29
0 numeros 857 31
4 [ 857 38
0 indice 857 39
4 ] 857 45
4 ; 857 46
0 indice 858 9
3 = 858 16
0 indice 858 18
3 + 858 25
1 1 858 27
4 ; 858 28
4 } 859 5
0 promedio 861 5
3 = 861 14
0 suma 861 16
3 / 861 21
1 10.0 861 23
4 ; 861 27
5 for 864 5 8
0 x 864 9
5 in 864 11 9
1 1 864 14
3 . 864 15
3 . 864 16
1 20 864 17
4 { 864 20
5 for 865 9 8
0 y 865 13
5 in 865 15 9
1 1 865 18
3 . 865 19
3 . 865 20
1 20 865 21
4 { 865 24
5 let 866 13 1
0 multiplicacion 866 17
3 = 866 32
0 x 866 34
3 * 866 36
0 y 866 38
4 ; 866 39
5 if 868 13 3
0 multiplicacion 868 16
3 % 868 31
1 3 868 33
3 == 868 35
1 0 868 38
4 { 868 40
5 if 869 17 3
0 multiplicacion 869 20
3 % 869 35
1 5 869 37
3 == 869 39
1 0 869 42
4 { 869 44
5 let 870 21 1
0 especial 870 25
3 = 870 34
0 multiplicacion 870 36
3 / 870 51
1 15 870 53
4 ; 870 55
4 } 871 17
5 else 871 19 4
4 { 871 24
5 let 872 21 1
0 normal 872 25
3 = 872 32
0 multiplicacion 872 34
3 / 872 49
1 3 872 51
4 ; 872 52
4 } 873 17
4 } 874 13
4 } 875 9
4 } 876 5
5 let 879 5 1
5 mut 879 9 2
0 matriz 879 13
6 : 879 19
0 i32 879 21
3 = 879 25
1 0 879 27
4 ; 879 28
5 let 880 5 1
0 filas 880 9
6 : 880 14
0 i32 880 16
3 = 880 20
1 5 880 22
4 ; 880 23
5 let 881 5 1
0 columnas 881 9
6 : 881 17
0 i32 881 19
3 = 881 23
1 5 881 25
4 ; 881 26
5 for 883 5 8
0 i 883 9
5 in 883 11 9
1 0 883 14
3 . 883 15
3 . 883 16
0 filas 883 17
4 { 883 23
5 for 884 9 8
0 j 884 13
5 in 884 15 9
1 0 884 18
3 . 884 19
3 . 884 20
0 columnas 884 21
4 { 884 30
0 matriz 885 13
3 = 885 20
0 i 885 22
3 * 885 24
0 columnas 885 26
3 + 885 35
0 j 885 37
4 ; 885 38
5 let 886 13 1
0 valor 886 17
3 = 886 23
0 matriz 886 25
3 * 886 32
1 2 886 34
3 + 886 36
1 1 886 38
4 ; 886 39
4 } 887 9
4 } 888 5
5 let 891 5 1
0 cadena1 891 9
6 : 891 16
0 str 891 18
3 = 891 22
2 "Hola" 891 24
4 ; 891 30
5 let 892 5 1
0 cadena2 892 9
6 : 892 16
0 str 892 18
3 = 892 22
2 "Mundo" 892 24
4 ; 892 31
5 let 893 5 1
0 longitud1 893 9
3 = 893 19
0 len 893 21
4 ( 893 24
0 cadena1 893 25
4 ) 893 32
4 ; 893 33
5 let 894 5 1
0 longitud2 894 9
3 = 894 19
0 len 894 21
4 ( 894 24
0 cadena2 894 25
4 ) 894 32
4 ; 894 33
5 match 897 5 5
0 contador 897 11
4 { 897 20
1 0 898 9
3 = 898 11
3 > 898 12
5 let 898 14 1
0 cero 898 18
3 = 898 23
5 true 898 25 13
4 , 898 29
1 1 899 9
3 = 899 11
3 > 899 12
5 let 899 14 1
0 uno 899 18
3 = 899 22
5 true 899 24 13
4 , 899 28
1 2 900 9
3 = 900 11
3 > 900 12
5 let 900 14 1
0 dos 900 18
3 = 900 22
5 true 900 24 13
4 , 900 28
0 _ 901 9
3 = 901 11
3 > 901 12
5 let 901 14 1
0 otro 901 18
3 = 901 23
5 true 901 25 13
4 , 901 29
4 } 902 5
5 loop 905 5 7
4 { 905 10
0 contador 906 9
3 = 906 18
0 contador 906 20
3 - 906 29
1 1 906 31
4 ; 906 32
5 if 908 9 3
0 contador 908 12
3 <= 908 21
1 0 908 24
4 { 908 26
5 break 909 13 10
4 ; 909 18
4 } 910 9
5 let 912 9 1
0 temporal 912 13
3 = 912 22
0 contador 912 24
3 * 912 33
1 3 912 35
4 ; 912 36
5 if 914 9 3
0 temporal 914 12
3 > 914 21
1 200 914 23
4 { 914 27
5 continue 915 13 11
4 ; 915 21
4 } 916 9
4 } 917 5
5 let 920 5 1
0 resultado_complejo 920 9
3 = 920 28
0 calcular_complejo 920 30
4 ( 920 47
4 ) 920 48
4 ; 920 49
5 let 921 5 1
5 mut 921 9 2
0 acumulador 921 13
6 : 921 23
0 f64 921 25
3 = 921 29
1 0.0 921 31
4 ; 921 34
5 let 922 5 1
0 precision 922 9
6 : 922 18
0 f64 922 20
3 = 922 24
1 0.001 922 26
4 ; 922 31
5 for 925 5 8
0 iteracion 925 9
5 in 925 19 9
1 1 925 22
3 . 925 23
3 . 925 24
1 100 925 25
4 { 925 29
5 let 926 9 1
0 valor_actual 926 13
3 = 926 26
0 iteracion 926 28
3 * 926 38
0 pi 926 40
4 ; 926 42
0 acumulador 927 9
3 = 927 20
0 acumulador 927 22
3 + 927 33
0 valor_actual 927 35
4 ; 927 47
5 if 929 9 3
0 acumulador 929 12
3 > 929 23
1 1000.0 929 25
4 { 929 32
5 let 930 13 1
0 diferencia 930 17
3 = 930 28
0 acumulador 930 30
3 - 930 41
1 1000.0 930 43
4 ; 930 49
5 if 932 13 3
0 diferencia 932 16
3 < 932 27
0 precision 932 29
4 { 932 39
5 break 933 17 10
4 ; 933 22
4 } 934 13
4 } 935 9
4 } 936 5
4 } 937 1
5 fn 939 1 0
0 fibonacci 939 4
4 ( 939 13
0 n 939 14
6 : 939 15
0 i32 939 17
4 ) 939 20
3 - 939 22
3 > 939 23
0 i32 939 25
4 { 939 29
5 if 940 5 3
0 n 940 8
3 <= 940 10
1 1 940 13
4 { 940 15
5 return 941 9 12
0 n 941 16
4 ; 941 17
4 } 942 5
5 let 944 5 1
5 mut 944 9 2
0 a 944 13
6 : 944 14
0 i32 944 16
3 = 944 20
1 0 944 22
4 ; 944 23
5 let 945 5 1
5 mut 945 9 2
0 b 945 13
6 : 945 14
0 i32 945 16
3 = 945 20
1 1 945 22
4 ; 945 23
5 let 946 5 1
5 mut 946 9 2
0 temp 946 13
6 : 946 17
0 i32 946 19
3 = 946 23
1 0 946 25
4 ; 946 26
5 for 948 5 8
0 i 948 9
5 in 948 11 9
1 2 948 14
3 . 948 15
3 . 948 16
0 n 948 17
3 + 948 18
1 1 948 19
4 { 948 21
0 temp 949 9
3 = 949 14
0 a 949 16
3 + 949 18
0 b 949 20
4 ; 949 21
0 a 950 9
3 = 950 11
0 b 950 13
4 ; 950 14
0 b 951 9
3 = 951 11
0 temp 951 13
4 ; 951 17
4 } 952 5
5 return 954 5 12
0 b 954 12
4 ; 954 13
4 } 955 1
5 fn 957 1 0
0 factorial 957 4
4 ( 957 13
0 n 957 14
6 : 957 15
0 i32 957 17
4 ) 957 20
3 - 957 22
3 > 957 23
0 i32 957 25
4 { 957 29
5 if 958 5 3
0 n 958 8
3 <= 958 10
1 1 958 13
4 { 958 15
5 return 959 9 12
1 1 959 16
4 ; 959 17
4 } 960 5
5 let 962 5 1
5 mut 962 9 2
0 resultado 962 13
6 : 962 22
0 i32 962 24
3 = 962 28
1 1 962 30
4 ; 962 31
5 let 963 5 1
5 mut 963 9 2
0 i 963 13
6 : 963 14
0 i32 963 16
3 = 963 20
1 2 963 22
4 ; 963 23
5 while 965 5 6
0 i 965 11
3 <= 965 13
0 n 965 16
4 { 965 18
0 resultado 966 9
3 = 966 19
0 resultado 966 21
3 * 966 31
0 i 966 33
4 ; 966 34
0 i 967 9
3 = 967 11
0 i 967 13
3 + 967 15
1 1 967 17
4 ; 967 18
4 } 968 5
5 return 970 5 12
0 resultado 970 12
4 ; 970 21
4 } 971 1
5 fn 973 1 0
0 bubble_sort 973 4
4 ( 973 15
4 ) 973 16
3 - 973 18
3 > 973 19
0 i32 973 21
4 { 973 25
5 let 974 5 1
5 mut 974 9 2
0 arr 974 13
3 = 974 17
4 [ 974 19
1 64 974 20
4 , 974 22
1 34 974 24
4 , 974 26
1 25 974 28
4 , 974 30
1 12 974 32
4 , 974 34
1 22 974 36
4 , 974 38
1 11 974 40
4 , 974 42
1 90 974 44
4 ] 974 46
4 ; 974 47
5 let 975 5 1
0 n 975 9
6 : 975 10
0 i32 975 12
3 = 975 16
1 7 975 18
4 ; 975 19
5 for 977 5 8
0 i 977 9
5 in 977 11 9
1 0 977 14
3 . 977 15
3 . 977 16
0 n 977 17
3 - 977 18
1 1 977 19
4 { 977 21
5 for 978 9 8
0 j 978 13
5 in 978 15 9
1 0 978 18
3 . 978 19
3 . 978 20
0 n 978 21
3 - 978 22
0 i 978 23
3 - 978 24
1 1 978 25
4 { 978 27
5 if 979 13 3
0 arr 979 16
4 [ 979 19
0 j 979 20
4 ] 979 21
3 > 979 23
0 arr 979 25
4 [ 979 28
0 j 979 29
3 + 979 30
1 1 979 31
4 ] 979 32
4 { 979 34
5 let 980 17 1
0 temp 980 21
3 = 980 26
0 arr 980 28
4 [ 980 31
0 j 980 32
4 ] 980 33
4 ; 980 34
0 arr 981 17
4 [ 981 20
0 j 981 21
4 ] 981 22
3 = 981 24
0 arr 981 26
4 [ 981 29
0 j 981 30
3 + 981 31
1 1 981 32
4 ] 981 33
4 ; 981 34
0 arr 982 17
4 [ 982 20
0 j 982 21
3 + 982 22
1 1 982 23
4 ] 982 24
3 = 982 26
0 temp 982 28
4 ; 982 32
4 } 983 13
4 } 984 9
4 } 985 5
5 return 987 5 12
1 0 987 12
4 ; 987 13
4 } 988 1
5 fn 990 1 0
0 binary_search 990 4
4 ( 990 17
0 arr 990 18
6 : 990 21
0 i32 990 23
4 , 990 26
0 target 990 28
6 : 990 34
0 i32 990 36
4 ) 990 39
3 - 990 41
3 > 990 42
0 i32 990 44
4 { 990 48
5 let 991 5 1
5 mut 991 9 2
0 left 991 13
6 : 991 17
0 i32 991 19
3 = 991 23
1 0 991 25
4 ; 991 26
5 let 992 5 1
5 mut 992 9 2
0 right 992 13
6 : 992 18
0 i32 992 20
3 = 992 24
1 9 992 26
4 ; 992 27
5 while 994 5 6
0 left 994 11
3 <= 994 16
0 right 994 19
4 { 994 25
5 let 995 9 1
0 mid 995 13
3 = 995 17
0 left 995 19
3 + 995 24
4 ( 995 26
0 right 995 27
3 - 995 33
0 left 995 35
4 ) 995 39
3 / 995 41
1 2 995 43
4 ; 995 44
5 if 997 9 3
0 arr 997 12
3 == 997 16
0 target 997 19
4 { 997 26
6 # 997 27
5 return 998 13 12
0 mid 998 20
4 ; 998 23
4 } 999 9
6 @ 1000 9
7 EOF 1000 10

# Total de tokens: 4169
